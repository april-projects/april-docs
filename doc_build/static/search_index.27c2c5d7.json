[
  {
    "id": 0,
    "title": "常用编程技巧和代码规范总结",
    "content": "#\n\n\n一、前言#\n\n> April（四月）\n> 是以我的猫咪命名的一个开源团队，创立初衷是为了孵化一些项目到社区，意味着后续也会接受来自其他代码贡献者的代码，但是如果代码贡献者的编程风格与 April\n> 的不一致，会给代码阅读者和其他代码提交者造成不小的困扰. April因此总结了这份编程风格指南, 使所有提交代码的人都能获知 April 的编程风格.\n\n\n二、Java 编码规范#\n\nJava 编程规范主要以阿里巴巴代码规约为主 ( GitHub 无法预览 PDF，可以 clone 本仓库，使用 typora 可以以 PDF\n方式查看下面的文档)\n\n\n三、编程技巧（补充）#\n\n\n一、注释规范#\n\n * 禁用行尾注释\n * 方法或常量，成员变量，禁单行注释，应使用文档注释\n\n注释配置#\n\n> File | Settings | Editor | File and Code Templates，依次配置 Files 下面的 Class\n> interface enum record @interface\n\n * 类注释模板\n\n\n\n * 枚举注释模板\n\n\n\n * 接口注释模板\n\n\n\n * 注解注释模板\n\n\n\n * 安全类\n\n\n\n--------------------------------------------------------------------------------\n\n\n二、建表规范#\n\n * 遵循三大范式\n * 复杂字段之间用 （_） 下划线相隔，如（create\\_time，user_name）\n * 禁止使用外键关联\n * 主键字段使用（bigint）类型，Java 对应类型使用 Long 类型\n * 日期类型字段是 （datetime），Java对应 LocalDateTime 类型\n\n--------------------------------------------------------------------------------\n\n\n三、查询规范#\n\n * 列表查询\n\n> 所有的列表查询都需要添加排序，已最后添加的数据显示在第一列，以 date_time 类型作为排序字段，如（创建时间create_time ）\n\n * 操作集合尽量使用 stream 和 lambda 表达式,工具类地址（com.mobaijun.common.collection.StreamUtil）\n\n--------------------------------------------------------------------------------\n\n\n四、返回规范#\n\n>  * 项目中定义了R返回类，目录地址（com.mobaijun.common.result）\n>    \n>    * R.ok(T) 成功返回\n>    * R.ok(T data, String message) 成功返回自定义消息\n>    * R.failed(HttpStatus failMsg); 失败返回自定义状态码\n>    * R.failed(HttpStatus failMsg, String message); 失败返回自定义状态码和自定义消息\n>    \n>    返回示例：\n>    \n>    \n> \n>  * 项目中返回只能在 controller 层进行操作，禁止在业务层（service）返回\n> \n>  * 业务层如果需要异常处理，使用 throw new Exception(\"\") 进行处理;\n\n--------------------------------------------------------------------------------\n\n\n五、增删改查返回规范#\n\n * 新增：返回 boolean 类型或对象\n * 修改：返回 boolean 类型或对象\n * 删除：返回 int 类型\n * 查询：返回 List 类型或 Entity 类型\n * 批量：返回 int 类型\n\n--------------------------------------------------------------------------------\n\n\n六、接口规范#\n\n * 类定义信息为 @Api(tags = {\"一级目录-二级目录-业务类型\"}, description = \"具体描述\")\n * 查询使用：@GetMapping(value = \"/${methodName}\")\n * 新增使用：@PostMapping(value = \"/${methodName}\")\n * 修改使用：@PutMapping(value = \"/${methodName}\")\n * 单个删除：@DeleteMapping(value = \"/${methodName}\")\n * 批量删除：@DeleteMapping(value = \"/${methodName}\")\n\n> 命名规则：\n> \n>  * 单个删除（singleDelete）\n>  * 批量删除（batchDelete）\n>  * 新增 （insert[Entity]）\n>  * 修改 （update[Entity]）\n>  * 查询 （select[Entity]List）\n\n--------------------------------------------------------------------------------\n\n\n七、枚举定义规范#\n\n 1. 枚举如果没有set方法，属性需要使用 final 定义；\n 2. 枚举每个字段需包含文档注释\n 3. 枚举属性全部定义为大写，多个单纯之间以下划线分割\n\n\n\n--------------------------------------------------------------------------------\n\n\n八、编码技巧#\n\n成员变量#\n\n * 成员变量禁用 idea 告警关键字，例如\n   * width、height\n\n异常处理#\n\n> 如遇到多资源关闭应使用（try-with-resources）语法\n\n * 参考链接传送地址\n\n\n\n工具类使用：#\n\n非必要不新增工具类，以 kjs-common 包工具类为准，大多数场景已经可以完全应付\n\n\n\n * 依赖关系图\n\n\n\n集合处理#\n\n集合处理使用 Java 8 新特性 lambda 结合 Stream 操作，例如：\n\n\n\n> 上方代码来自 april-wallpaper 项目\n\n对象实体转换#\n\n对象之间的属性赋值应该使用 mapstruct 进行转换，示例代码：\n\n\n\n\n九丶判断规范#\n\n\n\n示例代码：#\n\n\n\n--------------------------------------------------------------------------------\n\n\n四、代码提交#\n\n\nidea 忽略文件：#\n\n> File | Settings | Editor | File Types\n> \n> 忽略掉 |*.iml |.idea |.mvn |.mvnw |mvnw |mvnw.cmd |target\n\n\n提交规范#\n\n主要以 GitMoji 规范为主，gitmoji 是一个标准化和解释在GitHub提交消息上使用 emoji 的倡议。 gitmoji\n是一个开源项目，专门规定了在 github 提交代码时应当遵循的 emoji 规范，在 git commit上使用 emoji\n提供了一种简单的方法，仅通过查看所使用的表情符号来确定提交的目的或意图。\n\n在执行 git commit 指令时使用 emoji 图标为本次提交添加一个特别的图标，\n这个本次提交的记录很容易突出重点，或者说光看图标就知道本次提交的目的。这样就方便在日后查看历史提交日子记录中快速的查找到对于的提交版本。由于有很多不同的表情符号\n，表情库更新后，没有一个可以帮助更轻松地使用表情符号的中文表情库列表。\n\n提交示例，图标地址传送门\n\n",
    "routePath": "/guide/basic/",
    "lang": "",
    "toc": [
      {
        "text": "一、前言",
        "id": "一前言",
        "depth": 2,
        "charIndex": 3
      },
      {
        "text": "二、Java 编码规范",
        "id": "二java-编码规范",
        "depth": 2,
        "charIndex": 181
      },
      {
        "text": "三、编程技巧（补充）",
        "id": "三编程技巧补充",
        "depth": 2,
        "charIndex": 280
      },
      {
        "text": "一、注释规范",
        "id": "一注释规范",
        "depth": 3,
        "charIndex": 294
      },
      {
        "text": "注释配置",
        "id": "注释配置",
        "depth": 4,
        "charIndex": 342
      },
      {
        "text": "二、建表规范",
        "id": "二建表规范",
        "depth": 3,
        "charIndex": 603
      },
      {
        "text": "三、查询规范",
        "id": "三查询规范",
        "depth": 3,
        "charIndex": 851
      },
      {
        "text": "四、返回规范",
        "id": "四返回规范",
        "depth": 3,
        "charIndex": 1108
      },
      {
        "text": "五、增删改查返回规范",
        "id": "五增删改查返回规范",
        "depth": 3,
        "charIndex": 1574
      },
      {
        "text": "六、接口规范",
        "id": "六接口规范",
        "depth": 3,
        "charIndex": 1777
      },
      {
        "text": "七、枚举定义规范",
        "id": "七枚举定义规范",
        "depth": 3,
        "charIndex": 2309
      },
      {
        "text": "八、编码技巧",
        "id": "八编码技巧",
        "depth": 3,
        "charIndex": 2486
      },
      {
        "text": "成员变量",
        "id": "成员变量",
        "depth": 4,
        "charIndex": 2495
      },
      {
        "text": "异常处理",
        "id": "异常处理",
        "depth": 4,
        "charIndex": 2545
      },
      {
        "text": "工具类使用：",
        "id": "工具类使用",
        "depth": 4,
        "charIndex": 2604
      },
      {
        "text": "集合处理",
        "id": "集合处理",
        "depth": 4,
        "charIndex": 2672
      },
      {
        "text": "对象实体转换",
        "id": "对象实体转换",
        "depth": 4,
        "charIndex": 2753
      },
      {
        "text": "九丶判断规范",
        "id": "九丶判断规范",
        "depth": 3,
        "charIndex": 2801
      },
      {
        "text": "示例代码：",
        "id": "示例代码",
        "depth": 4,
        "charIndex": 2812
      },
      {
        "text": "四、代码提交",
        "id": "四代码提交",
        "depth": 2,
        "charIndex": 2905
      },
      {
        "text": "idea 忽略文件：",
        "id": "idea-忽略文件",
        "depth": 3,
        "charIndex": 2915
      },
      {
        "text": "提交规范",
        "id": "提交规范",
        "depth": 3,
        "charIndex": 3030
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 1,
    "title": "介绍",
    "content": "#\n\n\nApril#\n\nApril\n组织致力于为项目的迅速发展提供一系列全面而强大的基础能力，以便用户能够在满足项目需求的同时迅速、灵活地进行功能的拓展。我们致力于构建一个开放而创新的生态系统，为\n开发者提供高效、可靠的工具和资源，帮助他们更轻松地实现项目的快速迭代和卓越发展。我们的目标是为用户创造一个富有活力的开发环境，使他们能够在不断变化的技术和市场要\n求中保持敏捷和竞争力。通过整合丰富的基础能力，April 为开发者提供了一个稳固的基础，助力他们专注于项目的核心创新，实现更快、更灵活的产品交付。\n\n\n前言#\n\n在使用其他后台管理脚手架进行开发时，常常会遇到由于项目业务需求需要进行二次开发的情况。然而，在长时间的开发过程中，一旦源项目进行迭代升级，同步更新变得十分困难。\n\n因此，April 组织建议在项目开发中采用依赖的方式引入 April 组织提供的所有功能。这样，在后续跟随 April\n组织版本升级时，只需修改相应的依赖版本号，即可轻松完成同步更新。\n\nApril 已将所有 JAR 包推送至中央仓库，并为每个版本升级提供了相应的 SQL 改动文件。\n\n如果在使用过程中遇到必须通过二次开发修改源码才能解决的问题或实现特定功能的情况，我们欢迎您提出 issues。若这个功能具有通用性，我们将考虑为 April\n添加相应的能力，同时也欢迎您直接提交 PR 进行改动。我们致力于创建一个开放、灵活且与时俱进的开发环境，共同推动项目的进步与创新。\n\n\n项目仓库#\n\n项目                       描述                                                            GITHUB\napril-wallpaper          一个每日自动拉取壁纸写入readme文件的程序                                       april-projects/april-wallpaper: 一个每日自动拉取壁纸写入readme文件的程序\napril-zh-hotspot-push    利用GitHub actions                                              april-projects/april-zh-hotspot-push: 知乎热点推送\n                         自动爬取知乎每日热榜50条，目前已支持接入钉钉机器人，飞书机器人.(本地jdk版本最低11)\napril-script-and-tools   该项目旨在提供一些常用的 Shell 脚本 和 批处理脚本，用于自动化工作流程、软件包管理、漏洞修复以及代码质量提升。   april-projects/april-script-and-tools: Commonly used shell\n                                                                                       scripts and batch scripts at work\n\n\n加入我们#\n\n欢迎加入我们！我们正在寻找具备专业前端和多语言开发经验的优秀开发者，无论您擅长哪种语言，只要您对开源充满热情，我们都欢迎您的加入。\n\n如果您对项目的发展充满热情，愿意为开源事业贡献自己的力量，并且不介意目前项目是无报酬的，我们期待您的参与。您可以通过微信联系我们，微信号：[kjs-mobaij\nun]。\n\n加入我们的团队，您将有机会参与到创新的项目中，与志同道合的开发者共同探讨和推动开源技术的发展。期待您的加入，共同打造更加开放、充满活力的开发社区！",
    "routePath": "/guide/",
    "lang": "",
    "toc": [
      {
        "text": "April",
        "id": "april",
        "depth": 2,
        "charIndex": 3
      },
      {
        "text": "前言",
        "id": "前言",
        "depth": 2,
        "charIndex": 255
      },
      {
        "text": "项目仓库",
        "id": "项目仓库",
        "depth": 2,
        "charIndex": 633
      },
      {
        "text": "加入我们",
        "id": "加入我们",
        "depth": 2,
        "charIndex": 1350
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 3,
    "title": "综合资源与社区支持",
    "content": "前言#\n\n欢迎来到我们的编程学习与开发资源中心！这是一个专为编程爱好者、初学者和专业开发者设计的综合性教程页面。无论你是刚刚踏入编程世界，还是希望提升现有技能，这里都有适\n合你的内容。我们的目标是提供详尽的学习资料、实用的代码示例和实际应用案例，帮助你在编程之旅中不断进步。\n\n\nPython教程#\n\nPython因其简洁的语法和强大的功能而成为最受欢迎的编程语言之一。我们的Python教程覆盖了从基础语法到高级应用的各个方面。你将学习如何编写基本的Pytho\nn程序、进行数据分析、构建Web应用以及机器学习和人工智能的基础知识。通过实际操作和项目练习，你将能够掌握Python编程的核心概念和技巧。\n\n\nJava教程#\n\nJava是一种面向对象的编程语言，广泛应用于企业级应用开发和安卓应用开发。我们的Java教程将带你从基础的语法和面向对象编程概念入手，逐步深入到高级主题如多线程\n编程、网络编程和数据库连接。通过丰富的案例和项目，你将能够轻松应对各种Java开发挑战。\n\n\nGit教程#\n\nGit是现代软件开发中不可或缺的版本控制系统。我们的Git教程将帮助你理解和掌握Git的基本操作和高级功能。你将学习如何初始化仓库、提交更改、分支管理和合并代码\n，以及与团队协作的最佳实践。通过动手实践，你将能够有效地管理项目代码，确保开发过程中的版本控制和协作顺利进行。\n\n\nLinux教程#\n\nLinux操作系统以其稳定性和高效性而受到开发者的青睐。我们的Linux教程从基础命令行操作开始，逐步深入到系统管理、网络配置和安全设置等高级主题。无论你是希望\n成为系统管理员，还是开发者需要在Linux环境下工作，这里的内容都将帮助你掌握必要的技能。\n\n\nMySQL教程#\n\nMySQL是最受欢迎的关系型数据库管理系统之一，广泛应用于各种应用开发中。我们的MySQL教程涵盖了数据库基础知识、SQL语法、数据操作和高级查询优化技巧。你将\n学习如何设计和管理数据库、执行复杂查询、优化性能以及数据备份与恢复等关键技能。\n\n\n综合资源与社区支持#\n\n除了各类编程语言和工具的教程外，我们还提供了大量的综合资源，如编程书籍推荐、在线课程资源、开发工具推荐等。同时，我们鼓励你加入我们的开发者社区，与全球的编程爱好\n者交流学习心得、分享项目经验，互相帮助，共同进步。\n\n我们致力于为你提供优质的学习资源和支持，助你在编程世界中探索和成长。开始你的学习之旅吧，未来的开发高手就是你！",
    "routePath": "/tutorial/",
    "lang": "",
    "toc": [],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 4,
    "title": "Python - 100天从新手到大师",
    "content": "#\n\n简单的说，Python是一个“优雅”、“明确”、“简单”的编程语言。\n\n * 学习曲线低，非专业人士也能上手\n * 开源系统，拥有强大的生态圈\n * 解释型语言，完美的平台可移植性\n * 动态类型语言，支持面向对象和函数式编程\n * 代码规范程度高，可读性强\n\nPython在以下领域都有用武之地。\n\n * 后端开发 - Python / Java / Go / PHP\n * DevOps - Python / Shell / Ruby\n * 数据采集 - Python / C++ / Java\n * 量化交易 - Python / C++ / R\n * 数据科学 - Python / R / Julia / Matlab\n * 机器学习 - Python / R / C++ / Julia\n * 自动化测试 - Python / Shell\n\n作为一名Python开发者，根据个人的喜好和职业规划，可以选择的就业领域也非常多。\n\n * Python后端开发工程师（服务器、云平台、数据接口）\n * Python运维工程师（自动化运维、SRE、DevOps）\n * Python数据分析师（数据分析、商业智能、数字化运营）\n * Python数据挖掘工程师（机器学习、深度学习、算法专家）\n * Python爬虫工程师\n * Python测试工程师（自动化测试、测试开发）\n\n> 说明：目前，数据分析和数据挖掘是非常热门的方向，因为不管是互联网行业还是传统行业都已经积累了大量的数据，各行各业都需要数据分析师从已有的数据中发现更多的商业\n> 价值，从而为企业的决策提供数据的支撑，这就是所谓的数据驱动决策。\n\n给初学者的几个建议：\n\n * Make English as your working language. （让英语成为你的工作语言）\n * Practice makes perfect. （熟能生巧）\n * All experience comes from mistakes. （所有的经验都源于你犯过的错误）\n * Don't be one of the leeches. （不要当伸手党）\n * Either outstanding or out. （要么出众，要么出局）\n\n\nDay01~15 - Python语言基础#\n\nDay01 - 初识Python#\n\n * Python简介 - Python的历史 / Python的优缺点 / Python的应用领域\n * 搭建编程环境 - Windows环境 / Linux环境 / MacOS环境\n * 从终端运行Python程序 - Hello, world / print函数 / 运行程序\n * 使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE\n * 注释 - 注释的作用 / 单行注释 / 多行注释\n\nDay02 - 语言元素#\n\n * 程序和进制 - 指令和程序 / 冯诺依曼机 / 二进制和十进制 / 八进制和十六进制\n * 变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换\n * 数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码\n * 运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级\n * 应用案例 - 华氏温度转换成摄氏温度 / 输入圆的半径计算周长和面积 / 输入年份判断是否是闰年\n\nDay03 - 分支结构#\n\n * 分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\n * if语句 - 简单的if / if-else结构 / if-elif-else结构 / 嵌套的if\n * 应用案例 - 用户身份验证 / 英制单位与公制单位互换 / 掷骰子决定做什么 / 百分制成绩转等级制 / 分段函数求值 /\n   输入三条边的长度如果能构成三角形就计算周长和面积\n\nDay04 - 循环结构#\n\n * 循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\n * while循环 - 基本结构 / break语句 / continue语句\n * for循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序\n * 应用案例 - 1~100求和 / 判断素数 / 猜数字游戏 / 打印九九表 / 打印三角形图案 / 猴子吃桃 / 百钱百鸡\n\nDay05 - 构造程序逻辑#\n\n * 经典案例：水仙花数 / 百钱百鸡 / Craps赌博游戏\n * 练习题目：斐波那契数列 / 完美数 / 素数\n\nDay06 - 函数和模块的使用#\n\n * 函数的作用 - 代码的坏味道 / 用函数封装功能模块\n * 定义函数 - def关键字 / 函数名 / 参数列表 / return语句 / 调用自定义函数\n * 调用函数 - Python内置函数 / 导入模块和函数\n * 函数的参数 - 默认参数 / 可变参数 / 关键字参数 / 命名关键字参数\n * 函数的返回值 - 没有返回值 / 返回单个值 / 返回多个值\n * 作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字\n * 用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块）\n\nDay07 - 字符串和常用数据结构#\n\n * 字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法\n * 列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历\n * 列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找\n * 生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器\n * 元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换\n * 集合基本用法 - 集合和列表的区别 / 创建集合 / 添加元素 / 删除元素 / 清空\n * 集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集\n * 字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空\n * 字典常用操作 - keys方法 / values方法 / items方法 / setdefault方法\n * 基础练习 - 跑马灯效果 / 列表找最大元素 / 统计考试成绩的平均分 / Fibonacci数列 / 杨辉三角\n * 综合案例 - 双色球选号 / 井字棋\n\nDay08 - 面向对象编程基础#\n\n * 类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念\n * 定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / __str__方法\n * 使用对象 - 创建对象 / 给对象发消息\n * 面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态\n * 基础练习 - 定义学生类 / 定义时钟类 / 定义图形类 / 定义汽车类\n\nDay09 - 面向对象进阶#\n\n * 属性 - 类属性 / 实例属性 / 属性访问器 / 属性修改器 / 属性删除器 / 使用__slots__\n * 类中的方法 - 实例方法 / 类方法 / 静态方法\n * 运算符重载 - __add__ / __sub__ / __or__ /__getitem__ / __setitem__ / __len__ /\n   __repr__ / __gt__ / __lt__ / __le__ / __ge__ / __eq__ / __ne__ / __contains__\n * 类(的对象)之间的关系 - 关联 / 继承 / 依赖\n * 继承和多态 - 什么是继承 / 继承的语法 / 调用父类方法 / 方法重写 / 类型判定 / 多重继承 / 菱形继承(钻石继承)和C3算法\n * 综合案例 - 工资结算系统 / 图书自动折扣系统 / 自定义分数类\n\nDay10 - 图形用户界面和游戏开发#\n\n * 使用tkinter开发GUI程序\n * 使用pygame三方库开发游戏应用\n * “大球吃小球”游戏\n\nDay11 - 文件和异常#\n\n * 读文件 - 读取整个文件 / 逐行读取 / 文件路径\n * 写文件 - 覆盖写入 / 追加写入 / 文本文件 / 二进制文件\n * 异常处理 - 异常机制的重要性 / try-except代码块 / else代码块 / finally代码块 / 内置异常类型 / 异常栈 /\n   raise语句\n * 数据持久化 - CSV文件概述 / csv模块的应用 / JSON数据格式 / json模块的应用\n\nDay12 - 字符串和正则表达式#\n\n * 字符串高级操作 - 转义字符 / 原始字符串 / 多行字符串 / in和not in运算符 / is_xxx方法 / join和split方法 /\n   strip相关方法 / pyperclip模块 / 不变字符串和可变字符串 / StringIO的使用\n * 正则表达式入门 - 正则表达式的作用 / 元字符 / 转义 / 量词 / 分组 / 零宽断言 /贪婪匹配与惰性匹配懒惰 /\n   使用re模块实现正则表达式操作（匹配、搜索、替换、捕获）\n * 使用正则表达式 - re模块 / compile函数 / group和groups方法 / match方法 / search方法 /\n   findall和finditer方法 / sub和subn方法 / split方法\n * 应用案例 - 使用正则表达式验证输入的字符串\n\nDay13 - 进程和线程#\n\n * 进程和线程的概念 - 什么是进程 / 什么是线程 / 多线程的应用场景\n * 使用进程 - fork函数 / multiprocessing模块 / 进程池 / 进程间通信\n * 使用线程 - threading模块 / Thread类 / RLock类 / Condition类 / 线程池\n\nDay14 - 网络编程入门和网络应用开发#\n\n * 计算机网络基础 - 计算机网络发展史 / “TCP-IP”模型 / IP地址 / 端口 / 协议 / 其他相关概念\n * 网络应用模式 - “客户端-服务器”模式 / “浏览器-服务器”模式\n * 基于HTTP协议访问网络资源 - 网络API概述 / 访问URL / requests三方库 / 解析JSON格式数据\n * Python网络编程 - 套接字的概念 / socket模块 / socket函数 / 创建TCP服务器 / 创建TCP客户端 / 创建UDP服务器 /\n   创建UDP客户端\n * 电子邮件 - SMTP协议 / POP3协议 / IMAP协议 / smtplib模块 / poplib模块 / imaplib模块\n * 短信服务 - 调用短信服务网关\n\nDay15 - 图像和文档处理#\n\n * 用Pillow处理图片 - 图片读写 / 图片合成 / 几何变换 / 色彩转换 / 滤镜效果\n * 读写Word文档 - 文本内容的处理 / 段落 / 页眉和页脚 / 样式的处理\n * 读写Excel文件 - xlrd / xlwt / openpyxl\n\n\nDay16~Day20 - Python语言进阶 #\n\n * 常用数据结构\n * 函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器\n * 面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式\n * 迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 /\n * 并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await\n\n\nDay21~30 - Web前端入门#\n\n * 用HTML标签承载页面内容\n * 用CSS渲染页面\n * 用JavaScript处理交互式行为\n * jQuery入门和提高\n * Vue.js入门\n * Element的使用\n * Bootstrap的使用\n\n\nDay31~35 - 玩转Linux操作系统#\n\n * 操作系统发展史和Linux概述\n * Linux基础命令\n * Linux中的实用程序\n * Linux的文件系统\n * Vim编辑器的应用\n * 环境变量和Shell编程\n * 软件的安装和服务的配置\n * 网络访问和管理\n * 其他相关内容\n\n\nDay36~45 - 数据库基础和进阶#\n\nDay36 - 关系型数据库和MySQL概述#\n\n * 关系型数据库概述\n * MySQL简介\n * 安装MySQL\n * MySQL基本命令\n\nDay37 - SQL详解之DDL#\n\n * 建库建表\n * 删除表和修改表\n\nDay38 - SQL详解之DML#\n\n * insert操作\n * delete操作\n * update操作\n\nDay39 - SQL详解之DQL#\n\n * 投影和别名\n * 筛选数据\n * 空值处理\n * 去重\n * 排序\n * 聚合函数\n * 嵌套查询\n * 分组\n * 表连接\n   * 笛卡尔积\n   * 内连接\n   * 自然连接\n   * 外连接\n * 窗口函数\n   \n   * 定义窗口\n   \n   * 排名函数\n   \n   * 取数函数\n\nDay40 - SQL详解之DCL#\n\n * 创建用户\n * 授予权限\n * 召回权限\n\nDay41 - MySQL新特性#\n\n * JSON类型\n * 窗口函数\n * 公共表表达式\n\nDay42 - 视图、函数和过程#\n\n * 视图\n   * 使用场景\n   * 创建视图\n   * 使用限制\n * 函数\n   * 内置函数\n   * 用户自定义函数（UDF）\n * 过程\n   * 创建过程\n   * 调用过程\n\nDay43 - 索引#\n\n * 执行计划\n * 索引的原理\n * 创建索引\n   * 普通索引\n   * 唯一索引\n   * 前缀索引\n   * 复合索引\n * 注意事项\n\nDay44 - Python接入MySQL数据库#\n\n * 安装三方库\n * 创建连接\n * 获取游标\n * 执行SQL语句\n * 通过游标抓取数据\n * 事务提交和回滚\n * 释放连接\n * 编写ETL脚本\n\nDay45 - 大数据平台和HiveSQL#\n\n * Hadoop生态圈\n * Hive概述\n * 准备工作\n * 数据类型\n * DDL操作\n * DML操作\n * 数据查询\n\n\nDay46~60 - 实战Django#\n\nDay46 - Django快速上手#\n\n * Web应用工作机制\n * HTTP请求和响应\n * Django框架概述\n * 5分钟快速上手\n\nDay47 - 深入模型#\n\n * 关系型数据库配置\n * 使用ORM完成对模型的CRUD操作\n * 管理后台的使用\n * Django模型最佳实践\n * 模型定义参考\n\nDay48 - 静态资源和Ajax请求#\n\n * 加载静态资源\n * Ajax概述\n * 用Ajax实现投票功能\n\nDay49 - Cookie和Session#\n\n * 实现用户跟踪\n * cookie和session的关系\n * Django框架对session的支持\n * 视图函数中的cookie读写操作\n\nDay50 - 报表和日志#\n\n * 通过HttpResponse修改响应头\n * 使用StreamingHttpResponse处理大文件\n * 使用xlwt生成Excel报表\n * 使用reportlab生成PDF报表\n * 使用ECharts生成前端图表\n\nDay51 - 日志和调试工具栏#\n\n * 配置日志\n * 配置Django-Debug-Toolbar\n * 优化ORM代码\n\nDay52 - 中间件的应用#\n\n * 什么是中间件\n * Django框架内置的中间件\n * 自定义中间件及其应用场景\n\nDay53 - 前后端分离开发入门#\n\n * 返回JSON格式的数据\n * 用Vue.js渲染页面\n\nDay54 - RESTful架构和DRF入门#\n\n * REST概述\n * DRF库使用入门\n * 前后端分离开发\n * JWT的应用\n\nDay55 - RESTful架构和DRF进阶#\n\n * 使用CBV\n * 数据分页\n * 数据筛选\n\nDay56 - 使用缓存#\n\n * 网站优化第一定律\n\n * 在Django项目中使用Redis提供缓存服务\n\n * 在视图函数中读写缓存\n\n * 使用装饰器实现页面缓存\n\n * 为数据接口提供缓存服务\n\nDay57 - 接入三方平台#\n\n * 文件上传表单控件和图片文件预览\n * 服务器端如何处理上传的文件\n\nDay58 - 异步任务和定时任务#\n\n * 网站优化第二定律\n * 配置消息队列服务\n * 在项目中使用Celery实现任务异步化\n * 在项目中使用Celery实现定时任务\n\nDay59 - 单元测试#\n\nDay60 - 项目上线#\n\n * Python中的单元测试\n * Django框架对单元测试的支持\n * 使用版本控制系统\n * 配置和使用uWSGI\n * 动静分离和Nginx配置\n * 配置HTTPS\n * 配置域名解析\n\n\nDay61~65 - 爬虫开发#\n\nDay61 - 网络数据采集概述#\n\n * 网络爬虫的概念及其应用领域\n * 网络爬虫的合法性探讨\n * 开发网络爬虫的相关工具\n * 一个爬虫程序的构成\n\nDay62 - 数据抓取和解析#\n\n * 使用requests三方库实现数据抓取\n * 页面解析的三种方式\n   \n   * 正则表达式解析\n   \n   * XPath解析\n   \n   * CSS选择器解析\n\nDay63 - Python中的并发编程#\n\n * 多线程\n * 多进程\n * 异步I/O\n\nDay64 - 使用Selenium抓取网页动态内容#\n\n * 安装Selenium\n * 加载页面\n * 查找元素和模拟用户行为\n * 隐式等待和显示等待\n * 执行JavaScript代码\n * Selenium反爬破解\n * 设置无头浏览器\n\nDay65 - 爬虫框架Scrapy简介#\n\n * Scrapy核心组件\n * Scrapy工作流程\n * 安装Scrapy和创建项目\n * 编写蜘蛛程序\n * 编写中间件和管道程序\n * Scrapy配置文件\n\n\nDay66~80 - 数据分析#\n\nDay66 - 数据分析概述#\n\n * 数据分析师的职责\n * 数据分析师的技能栈\n * 数据分析相关库\n\nDay67 - 环境准备#\n\n * 安装和使用anaconda\n   * conda相关命令\n * 安装和使用jupyter-lab\n   * 安装和启动\n   * 使用小技巧\n\nDay68 - NumPy的应用-1#\n\n * 创建数组对象\n * 数组对象的属性\n * 数组对象的索引运算\n   * 普通索引\n   * 花式索引\n   * 布尔索引\n   * 切片索引\n * 案例：使用数组处理图像\n\nDay69 - NumPy的应用-2#\n\n * 数组对象的相关方法\n   * 获取描述性统计信息\n   * 其他相关方法\n\nDay70 - NumPy的应用-3#\n\n * 数组的运算\n   * 数组跟标量的运算\n   * 数组跟数组的运算\n * 通用一元函数\n * 通用二元函数\n * 广播机制\n * Numpy常用函数\n\nDay71 - NumPy的应用-4#\n\n * 向量\n * 行列式\n * 矩阵\n * 多项式\n\nDay72 - 深入浅出pandas-1#\n\n * 创建Series对象\n * Series对象的运算\n * Series对象的属性和方法\n\nDay73 - 深入浅出pandas-2#\n\n * 创建DataFrame对象\n * DataFrame对象的属性和方法\n * 读写DataFrame中的数据\n\nDay74 - 深入浅出pandas-3#\n\n * 数据重塑\n   * 数据拼接\n   * 数据合并\n * 数据清洗\n   * 缺失值\n   * 重复值\n   * 异常值\n   * 预处理\n\nDay75 - 深入浅出pandas-4#\n\n * 数据透视\n   * 获取描述性统计信息\n   * 排序和头部值\n   * 分组聚合\n   * 透视表和交叉表\n * 数据呈现\n\nDay76 - 深入浅出pandas-5#\n\n * 计算同比环比\n * 窗口计算\n * 相关性判定\n\nDay77 - 深入浅出pandas-6#\n\n * 索引的使用\n   * 范围索引\n   * 分类索引\n   * 多级索引\n   * 间隔索引\n   * 日期时间索引\n\nDay78 - 数据可视化-1#\n\n * 安装和导入matplotlib\n * 创建画布\n * 创建坐标系\n * 绘制图表\n   * 折线图\n   * 散点图\n   * 柱状图\n   * 饼状图\n   * 直方图\n   * 箱线图\n * 显示和保存图表\n\nDay79 - 数据可视化-2#\n\n * 高阶图表\n   * 气泡图\n   * 面积图\n   * 雷达图\n   * 玫瑰图\n   * 3D图表\n\nDay80 - 数据可视化-3#\n\n * Seaborn\n * Pyecharts\n\n\nDay81~90 - 机器学习和深度学习#\n\nDay81 - 机器学习基础#\n\nDay82 - k最近邻分类#\n\nDay83 - 决策树#\n\nDay84 - 贝叶斯分类#\n\nDay85 - 支持向量机#\n\nDay86 - K-均值聚类#\n\nDay87 - 回归分析#\n\nDay88 - 深度学习入门#\n\nDay89 - PyTorch概述#\n\nDay90 - PyTorch实战#\n\n\nDay91~100 - 团队项目开发#\n\n第91天：团队项目开发的问题和解决方案#\n\n 1. 软件过程模型\n    \n    * 经典过程模型（瀑布模型）\n      \n      * 可行性分析（研究做还是不做），输出《可行性分析报告》。\n      * 需求分析（研究做什么），输出《需求规格说明书》和产品界面原型图。\n      * 概要设计和详细设计，输出概念模型图（ER图）、物理模型图、类图、时序图等。\n      * 编码 / 测试。\n      * 上线 / 维护。\n      \n      瀑布模型最大的缺点是无法拥抱需求变化，整套流程结束后才能看到产品，团队士气低落。\n    \n    * 敏捷开发（Scrum）- 产品所有者、Scrum Master、研发人员 - Sprint\n      \n      * 产品的Backlog（用户故事、产品原型）。\n      * 计划会议（评估和预算）。\n      * 日常开发（站立会议、番茄工作法、结对编程、测试先行、代码重构……）。\n      * 修复bug（问题描述、重现步骤、测试人员、被指派人）。\n      * 发布版本。\n      * 评审会议（Showcase，用户需要参与）。\n      * 回顾会议（对当前迭代周期做一个总结）。\n      \n      > 补充：敏捷软件开发宣言\n      > \n      >  * 个体和互动 高于 流程和工具\n      >  * 工作的软件 高于 详尽的文档\n      >  * 客户合作 高于 合同谈判\n      >  * 响应变化 高于 遵循计划\n      \n      \n      \n      > 角色：产品所有者（决定做什么，能对需求拍板的人）、团队负责人（解决各种问题，专注如何更好的工作，屏蔽外部对开发团队的影响）、开发团队（项目执行人\n      > 员，具体指开发人员和测试人员）。\n      \n      > 准备工作：商业案例和资金、合同、憧憬、初始产品需求、初始发布计划、入股、组建团队。\n      \n      > 敏捷团队通常人数为8-10人。\n      \n      > 工作量估算：将开发任务量化，包括原型、Logo设计、UI设计、前端开发等，尽量把每个工作分解到最小任务量，最小任务量标准为工作时间不能超过两天，\n      > 然后估算总体项目时间。把每个任务都贴在看板上面，看板上分三部分：to do（待完成）、in progress（进行中）和done（已完成）。\n\n 2. 项目团队组建\n    \n    * 团队的构成和角色\n      \n      > 说明：感谢付祥英女士帮助我绘制了下面这张精美的公司组织架构图。\n      \n      \n    \n    * 编程规范和代码审查（flake8、pylint）\n      \n      \n    \n    * Python中的一些“惯例”（请参考《Python惯例-如何编写Pythonic的代码》）\n    \n    * 影响代码可读性的原因：\n      \n      * 代码注释太少或者没有注释\n      * 代码破坏了语言的最佳实践\n      * 反模式编程（意大利面代码、复制-黏贴编程、自负编程、……）\n\n 3. 团队开发工具介绍\n    \n    * 版本控制：Git、Mercury\n    * 缺陷管理：Gitlab、Redmine\n    * 敏捷闭环工具：禅道、JIRA\n    * 持续集成：Jenkins、Travis-CI\n    \n    请参考《团队项目开发的问题和解决方案》。\n\n项目选题和理解业务#\n\n 1. 选题范围设定\n    \n    * CMS（用户端）：新闻聚合网站、问答/分享社区、影评/书评网站等。\n    \n    * MIS（用户端+管理端）：KMS、KPI考核系统、HRS、CRM系统、供应链系统、仓储管理系统等。\n    \n    * App后台（管理端+数据接口）：二手交易类、报刊杂志类、小众电商类、新闻资讯类、旅游类、社交类、阅读类等。\n    \n    * 其他类型：自身行业背景和工作经验、业务容易理解和把控。\n\n 2. 需求理解、模块划分和任务分配\n    \n    * 需求理解：头脑风暴和竞品分析。\n    * 模块划分：画思维导图（XMind），每个模块是一个枝节点，每个具体的功能是一个叶节点（用动词表述），需要确保每个叶节点无法再生出新节点，确定每个叶子\n      节点的重要性、优先级和工作量。\n    * 任务分配：由项目负责人根据上面的指标为每个团队成员分配任务。\n    \n    \n\n 3. 制定项目进度表（每日更新）\n    \n    模块   功能     人员    状态     完成    工时   计划开始       实际开始   计划结束       实际结束   备注\n    评论   添加评论   王大锤   正在进行   50%   4    2018/8/7          2018/8/7          \n         删除评论   王大锤   等待     0%    2    2018/8/7          2018/8/7          \n         查看评论   白元芳   正在进行   20%   4    2018/8/7          2018/8/7          需要进行代码审查\n         评论投票   白元芳   等待     0%    4    2018/8/8          2018/8/8          \n\n 4. OOAD和数据库设计\n\n * UML（统一建模语言）的类图\n   \n   \n\n * 通过模型创建表（正向工程），例如在Django项目中可以通过下面的命令创建二维表。\n   \n   \n\n * 使用PowerDesigner绘制物理模型图。\n   \n   \n\n * 通过数据表创建模型（反向工程），例如在Django项目中可以通过下面的命令生成模型。\n   \n   \n\n第92天：Docker容器技术详解#\n\n 1. Docker简介\n 2. 安装Docker\n 3. 使用Docker创建容器（Nginx、MySQL、Redis、Gitlab、Jenkins）\n 4. 构建Docker镜像（Dockerfile的编写和相关指令）\n 5. 容器编排（Docker-compose）\n 6. 集群管理（Kubernetes）\n\n第93天：MySQL性能优化#\n\n 1. 基本原则\n 2. InnoDB引擎\n 3. 索引的使用和注意事项\n 4. 数据分区\n 5. SQL优化\n 6. 配置优化\n 7. 架构优化\n\n第94天：网络API接口设计#\n\n * 设计原则\n   * 关键问题\n   * 其他问题\n * 文档撰写\n\n第95天：[使用Django开发商业项目](./Day91-100/95.使用Django开发商业项 目.md)#\n\n项目开发中的公共问题#\n\n 1. 数据库的配置（多数据库、主从复制、数据库路由）\n 2. 缓存的配置（分区缓存、键设置、超时设置、主从复制、故障恢复（哨兵））\n 3. 日志的配置\n 4. 分析和调试（Django-Debug-ToolBar）\n 5. 好用的Python模块（日期计算、图像处理、数据加密、三方API）\n\nREST API设计#\n\n 1. RESTful架构\n    * 理解RESTful架构\n    * RESTful API设计指南\n    * RESTful API最佳实践\n 2. API接口文档的撰写\n    * RAP2\n    * YAPI\n 3. django-REST-framework的应用\n\n项目中的重点难点剖析#\n\n 1. 使用缓存缓解数据库压力 - Redis\n 2. 使用消息队列做解耦合和削峰 - Celery + RabbitMQ\n\n第96天：软件测试和自动化测试#\n\n单元测试#\n\n 1. 测试的种类\n 2. 编写单元测试（unittest、pytest、nose2、tox、ddt、……）\n 3. 测试覆盖率（coverage）\n\nDjango项目部署#\n\n 1. 部署前的准备工作\n    * 关键设置（SECRET_KEY / DEBUG / ALLOWED_HOSTS / 缓存 / 数据库）\n    * HTTPS / CSRF_COOKIE_SECUR / SESSION_COOKIE_SECURE\n    * 日志相关配置\n 2. Linux常用命令回顾\n 3. Linux常用服务的安装和配置\n 4. uWSGI/Gunicorn和Nginx的使用\n    * Gunicorn和uWSGI的比较\n      * 对于不需要大量定制化的简单应用程序，Gunicorn是一个不错的选择，uWSGI的学习曲线比Gunicorn要陡峭得多，Gunicorn的默认参\n        数就已经能够适应大多数应用程序。\n      * uWSGI支持异构部署。\n      * 由于Nginx本身支持uWSGI，在线上一般都将Nginx和uWSGI捆绑在一起部署，而且uWSGI属于功能齐全且高度定制的WSGI中间件。\n      * 在性能上，Gunicorn和uWSGI其实表现相当。\n 5. 使用虚拟化技术（Docker）部署测试环境和生产环境\n\n性能测试#\n\n 1. AB的使用\n 2. SQLslap的使用\n 3. sysbench的使用\n\n自动化测试#\n\n 1. 使用Shell和Python进行自动化测试\n 2. 使用Selenium实现自动化测试\n    * Selenium IDE\n    * Selenium WebDriver\n    * Selenium Remote Control\n 3. 测试工具Robot Framework介绍\n\n第97天：电商网站技术要点剖析#\n\n 1. 商业模式和需求要点\n 2. 物理模型设计\n 3. 第三方登录\n 4. 缓存预热和查询缓存\n 5. 购物车的实现\n 6. 支付功能集成\n 7. 秒杀和超卖问题\n 8. 静态资源管理\n 9. 全文检索方案\n\n第98天：项目部署上线和性能调优#\n\n 1. MySQL数据库调优\n 2. Web服务器性能优化\n    * Nginx负载均衡配置\n    * Keepalived实现高可用\n 3. 代码性能调优\n    * 多线程\n    * 异步化\n 4. 静态资源访问优化\n    * 云存储\n    * CDN\n\n第99天：面试中的公共问题#\n\n * 计算机基础\n * Python基础\n * Web框架相关\n * 爬虫相关问题\n * 数据分析\n * 项目相关\n\n第100天：Python面试题实录#",
    "routePath": "/tutorial/python/",
    "lang": "",
    "toc": [
      {
        "text": "Day01~15 - Python语言基础",
        "id": "day0115---python语言基础",
        "depth": 3,
        "charIndex": 954
      },
      {
        "text": "Day01 - 初识Python",
        "id": "day01---初识python",
        "depth": 4,
        "charIndex": 978
      },
      {
        "text": "Day02 - 语言元素",
        "id": "day02---语言元素",
        "depth": 4,
        "charIndex": 1217
      },
      {
        "text": "Day03 - 分支结构",
        "id": "day03---分支结构",
        "depth": 4,
        "charIndex": 1488
      },
      {
        "text": "Day04 - 循环结构",
        "id": "day04---循环结构",
        "depth": 4,
        "charIndex": 1685
      },
      {
        "text": "Day05 - 构造程序逻辑",
        "id": "day05---构造程序逻辑",
        "depth": 4,
        "charIndex": 1896
      },
      {
        "text": "Day06 - 函数和模块的使用",
        "id": "day06---函数和模块的使用",
        "depth": 4,
        "charIndex": 1972
      },
      {
        "text": "Day07 - 字符串和常用数据结构",
        "id": "day07---字符串和常用数据结构",
        "depth": 4,
        "charIndex": 2291
      },
      {
        "text": "Day08 - 面向对象编程基础",
        "id": "day08---面向对象编程基础",
        "depth": 4,
        "charIndex": 2825
      },
      {
        "text": "Day09 - 面向对象进阶",
        "id": "day09---面向对象进阶",
        "depth": 4,
        "charIndex": 3024
      },
      {
        "text": "Day10 - 图形用户界面和游戏开发",
        "id": "day10---图形用户界面和游戏开发",
        "depth": 4,
        "charIndex": 3426
      },
      {
        "text": "Day11 - 文件和异常",
        "id": "day11---文件和异常",
        "depth": 4,
        "charIndex": 3503
      },
      {
        "text": "Day12 - 字符串和正则表达式",
        "id": "day12---字符串和正则表达式",
        "depth": 4,
        "charIndex": 3725
      },
      {
        "text": "Day13 - 进程和线程",
        "id": "day13---进程和线程",
        "depth": 4,
        "charIndex": 4116
      },
      {
        "text": "Day14 - 网络编程入门和网络应用开发",
        "id": "day14---网络编程入门和网络应用开发",
        "depth": 4,
        "charIndex": 4283
      },
      {
        "text": "Day15 - 图像和文档处理",
        "id": "day15---图像和文档处理",
        "depth": 4,
        "charIndex": 4651
      },
      {
        "text": "Day16~Day20 - Python语言进阶",
        "id": "day16day20---python语言进阶",
        "depth": 3,
        "charIndex": -1
      },
      {
        "text": "Day21~30 - Web前端入门",
        "id": "day2130---web前端入门",
        "depth": 3,
        "charIndex": 5054
      },
      {
        "text": "Day31~35 - 玩转Linux操作系统",
        "id": "day3135---玩转linux操作系统",
        "depth": 3,
        "charIndex": 5185
      },
      {
        "text": "Day36~45 - 数据库基础和进阶",
        "id": "day3645---数据库基础和进阶",
        "depth": 3,
        "charIndex": 5338
      },
      {
        "text": "Day36 - 关系型数据库和MySQL概述",
        "id": "day36---关系型数据库和mysql概述",
        "depth": 4,
        "charIndex": 5360
      },
      {
        "text": "Day37 - SQL详解之DDL",
        "id": "day37---sql详解之ddl",
        "depth": 4,
        "charIndex": 5433
      },
      {
        "text": "Day38 - SQL详解之DML",
        "id": "day38---sql详解之dml",
        "depth": 4,
        "charIndex": 5473
      },
      {
        "text": "Day39 - SQL详解之DQL",
        "id": "day39---sql详解之dql",
        "depth": 4,
        "charIndex": 5530
      },
      {
        "text": "Day40 - SQL详解之DCL",
        "id": "day40---sql详解之dcl",
        "depth": 4,
        "charIndex": 5705
      },
      {
        "text": "Day41 - MySQL新特性",
        "id": "day41---mysql新特性",
        "depth": 4,
        "charIndex": 5750
      },
      {
        "text": "Day42 - 视图、函数和过程",
        "id": "day42---视图函数和过程",
        "depth": 4,
        "charIndex": 5798
      },
      {
        "text": "Day43 - 索引",
        "id": "day43---索引",
        "depth": 4,
        "charIndex": 5914
      },
      {
        "text": "Day44 - Python接入MySQL数据库",
        "id": "day44---python接入mysql数据库",
        "depth": 4,
        "charIndex": 6001
      },
      {
        "text": "Day45 - 大数据平台和HiveSQL",
        "id": "day45---大数据平台和hivesql",
        "depth": 4,
        "charIndex": 6107
      },
      {
        "text": "Day46~60 - 实战Django",
        "id": "day4660---实战django",
        "depth": 3,
        "charIndex": 6198
      },
      {
        "text": "Day46 - Django快速上手",
        "id": "day46---django快速上手",
        "depth": 4,
        "charIndex": 6220
      },
      {
        "text": "Day47 - 深入模型",
        "id": "day47---深入模型",
        "depth": 4,
        "charIndex": 6293
      },
      {
        "text": "Day48 - 静态资源和Ajax请求",
        "id": "day48---静态资源和ajax请求",
        "depth": 4,
        "charIndex": 6379
      },
      {
        "text": "Day49 - Cookie和Session",
        "id": "day49---cookie和session",
        "depth": 4,
        "charIndex": 6437
      },
      {
        "text": "Day50 - 报表和日志",
        "id": "day50---报表和日志",
        "depth": 4,
        "charIndex": 6537
      },
      {
        "text": "Day51 - 日志和调试工具栏",
        "id": "day51---日志和调试工具栏",
        "depth": 4,
        "charIndex": 6669
      },
      {
        "text": "Day52 - 中间件的应用",
        "id": "day52---中间件的应用",
        "depth": 4,
        "charIndex": 6734
      },
      {
        "text": "Day53 - 前后端分离开发入门",
        "id": "day53---前后端分离开发入门",
        "depth": 4,
        "charIndex": 6796
      },
      {
        "text": "Day54 - RESTful架构和DRF入门",
        "id": "day54---restful架构和drf入门",
        "depth": 4,
        "charIndex": 6847
      },
      {
        "text": "Day55 - RESTful架构和DRF进阶",
        "id": "day55---restful架构和drf进阶",
        "depth": 4,
        "charIndex": 6917
      },
      {
        "text": "Day56 - 使用缓存",
        "id": "day56---使用缓存",
        "depth": 4,
        "charIndex": 6969
      },
      {
        "text": "Day57 - 接入三方平台",
        "id": "day57---接入三方平台",
        "depth": 4,
        "charIndex": 7072
      },
      {
        "text": "Day58 - 异步任务和定时任务",
        "id": "day58---异步任务和定时任务",
        "depth": 4,
        "charIndex": 7126
      },
      {
        "text": "Day59 - 单元测试",
        "id": "day59---单元测试",
        "depth": 4,
        "charIndex": 7216
      },
      {
        "text": "Day60 - 项目上线",
        "id": "day60---项目上线",
        "depth": 4,
        "charIndex": 7231
      },
      {
        "text": "Day61~65 - 爬虫开发",
        "id": "day6165---爬虫开发",
        "depth": 3,
        "charIndex": 7347
      },
      {
        "text": "Day61 - 网络数据采集概述",
        "id": "day61---网络数据采集概述",
        "depth": 4,
        "charIndex": 7365
      },
      {
        "text": "Day62 - 数据抓取和解析",
        "id": "day62---数据抓取和解析",
        "depth": 4,
        "charIndex": 7444
      },
      {
        "text": "Day63 - Python中的并发编程",
        "id": "day63---python中的并发编程",
        "depth": 4,
        "charIndex": 7551
      },
      {
        "text": "Day64 - 使用Selenium抓取网页动态内容",
        "id": "day64---使用selenium抓取网页动态内容",
        "depth": 4,
        "charIndex": 7598
      },
      {
        "text": "Day65 - 爬虫框架Scrapy简介",
        "id": "day65---爬虫框架scrapy简介",
        "depth": 4,
        "charIndex": 7723
      },
      {
        "text": "Day66~80 - 数据分析",
        "id": "day6680---数据分析",
        "depth": 3,
        "charIndex": 7831
      },
      {
        "text": "Day66 - 数据分析概述",
        "id": "day66---数据分析概述",
        "depth": 4,
        "charIndex": 7849
      },
      {
        "text": "Day67 - 环境准备",
        "id": "day67---环境准备",
        "depth": 4,
        "charIndex": 7903
      },
      {
        "text": "Day68 - NumPy的应用-1",
        "id": "day68---numpy的应用-1",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day69 - NumPy的应用-2",
        "id": "day69---numpy的应用-2",
        "depth": 4,
        "charIndex": 8104
      },
      {
        "text": "Day70 - NumPy的应用-3",
        "id": "day70---numpy的应用-3",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day71 - NumPy的应用-4",
        "id": "day71---numpy的应用-4",
        "depth": 4,
        "charIndex": 8266
      },
      {
        "text": "Day72 - 深入浅出pandas-1",
        "id": "day72---深入浅出pandas-1",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day73 - 深入浅出pandas-2",
        "id": "day73---深入浅出pandas-2",
        "depth": 4,
        "charIndex": 8385
      },
      {
        "text": "Day74 - 深入浅出pandas-3",
        "id": "day74---深入浅出pandas-3",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day75 - 深入浅出pandas-4",
        "id": "day75---深入浅出pandas-4",
        "depth": 4,
        "charIndex": 8562
      },
      {
        "text": "Day76 - 深入浅出pandas-5",
        "id": "day76---深入浅出pandas-5",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day77 - 深入浅出pandas-6",
        "id": "day77---深入浅出pandas-6",
        "depth": 4,
        "charIndex": 8703
      },
      {
        "text": "Day78 - 数据可视化-1",
        "id": "day78---数据可视化-1",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day79 - 数据可视化-2",
        "id": "day79---数据可视化-2",
        "depth": 4,
        "charIndex": 8916
      },
      {
        "text": "Day80 - 数据可视化-3",
        "id": "day80---数据可视化-3",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "Day81~90 - 机器学习和深度学习",
        "id": "day8190---机器学习和深度学习",
        "depth": 3,
        "charIndex": 9033
      },
      {
        "text": "Day81 - 机器学习基础",
        "id": "day81---机器学习基础",
        "depth": 4,
        "charIndex": 9056
      },
      {
        "text": "Day82 - k最近邻分类",
        "id": "day82---k最近邻分类",
        "depth": 4,
        "charIndex": 9073
      },
      {
        "text": "Day83 - 决策树",
        "id": "day83---决策树",
        "depth": 4,
        "charIndex": 9090
      },
      {
        "text": "Day84 - 贝叶斯分类",
        "id": "day84---贝叶斯分类",
        "depth": 4,
        "charIndex": 9104
      },
      {
        "text": "Day85 - 支持向量机",
        "id": "day85---支持向量机",
        "depth": 4,
        "charIndex": 9120
      },
      {
        "text": "Day86 - K-均值聚类",
        "id": "day86---k-均值聚类",
        "depth": 4,
        "charIndex": 9136
      },
      {
        "text": "Day87 - 回归分析",
        "id": "day87---回归分析",
        "depth": 4,
        "charIndex": 9153
      },
      {
        "text": "Day88 - 深度学习入门",
        "id": "day88---深度学习入门",
        "depth": 4,
        "charIndex": 9168
      },
      {
        "text": "Day89 - PyTorch概述",
        "id": "day89---pytorch概述",
        "depth": 4,
        "charIndex": 9185
      },
      {
        "text": "Day90 - PyTorch实战",
        "id": "day90---pytorch实战",
        "depth": 4,
        "charIndex": 9205
      },
      {
        "text": "Day91~100 - 团队项目开发",
        "id": "day91100---团队项目开发",
        "depth": 3,
        "charIndex": 9226
      },
      {
        "text": "第91天：团队项目开发的问题和解决方案",
        "id": "第91天团队项目开发的问题和解决方案",
        "depth": 4,
        "charIndex": 9247
      },
      {
        "text": "第92天：Docker容器技术详解",
        "id": "第92天docker容器技术详解",
        "depth": 4,
        "charIndex": 11805
      },
      {
        "text": "第93天：MySQL性能优化",
        "id": "第93天mysql性能优化",
        "depth": 4,
        "charIndex": 11984
      },
      {
        "text": "第94天：网络API接口设计",
        "id": "第94天网络api接口设计",
        "depth": 4,
        "charIndex": 12076
      },
      {
        "text": "第95天：[使用Django开发商业项目](./Day91-100/95.使用Django开发商业项\t目.md)",
        "id": "第95天使用django开发商业项目day91-10095使用django开发商业项目md",
        "depth": 4,
        "charIndex": -1
      },
      {
        "text": "第96天：软件测试和自动化测试",
        "id": "第96天软件测试和自动化测试",
        "depth": 4,
        "charIndex": 12582
      },
      {
        "text": "第97天：电商网站技术要点剖析",
        "id": "第97天电商网站技术要点剖析",
        "depth": 4,
        "charIndex": 13403
      },
      {
        "text": "第98天：项目部署上线和性能调优",
        "id": "第98天项目部署上线和性能调优",
        "depth": 4,
        "charIndex": 13527
      },
      {
        "text": "第99天：面试中的公共问题",
        "id": "第99天面试中的公共问题",
        "depth": 4,
        "charIndex": 13681
      },
      {
        "text": "第100天：Python面试题实录",
        "id": "第100天python面试题实录",
        "depth": 4,
        "charIndex": -1
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 5,
    "title": "",
    "content": "第01课：初识Python#\n\n\nPython简介#\n\nPython（英式发音：/ˈpaɪθən/；美式发音：/ˈpaɪθɑːn/）是由荷兰人吉多·范罗苏姆（Guido von\nRossum）发明的一种编程语言，是目前世界上最受欢迎和拥有最多用户群体的编程语言。Python 强调代码的可读性和语法的简洁性，相较于 C 或\nJava，Python 让使用者能够用更少的代码表达自己的意图。下面是几个权威的编程语言排行榜给出的 Python 语言的排名，其中第1张图由 TIOBE\nIndex 提供，第3张图由 IEEE Spectrum 提供。值得一提的是第2张图，它展示了编程语言在全球最大代码托管平台 GitHub\n上受欢迎的程度，最近的四年时间 Python 语言都处于冠军的位置。\n\nPython的编年史#\n\n 1. 1989年12月：吉多·范罗苏姆决心开发一个新的脚本语言及其解释器来打发无聊的圣诞节。这种语言将作为 ABC 语言的继承者，主要用来替代 Unix\n    shell 和 C 语言实现系统管理。由于吉多本人是 BBC 电视剧《Monty Python's Flying Circus》的忠实粉丝，所以他选择了\n    Python 这个词作为新语言的名字。\n 2. 1991年02月：吉多·范罗苏姆在 alt.sources 新闻组上发布了 Python 解释器的最初代码，标记为版本0.9.0。\n 3. 1994年01月：Python 1.0发布，梦开始的地方。\n 4. 2000年10月：Python 2.0发布，Python 的整个开发过程更加透明，生态圈开始慢慢形成。\n 5. 2008年12月：Python 3.0发布，引入了诸多现代编程语言的新特性，但并不完全向下兼容。\n 6. 2011年04月：pip 首次发布，Python 语言有了自己的包管理工具。\n 7. 2018年07月：吉多·范罗苏姆宣布从“终身仁慈独裁者”（开源项目社区出现争议时拥有最终决定权的人）的职位上“永久休假”。\n 8. 2020年01月：在 Python 2和 Python 3共存了11年之后，官方停止了对 Python 2的更新和维护，希望用户尽快切换到 Python\n    3。\n\n> 说明：大多数软件的版本号一般分为三段，形如A.B.C，其中A表示大版本号，当软件整体重写升级或出现不向后兼容的改变时，才会增加A；B表示功能更新，出现新功能\n> 时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。\n\nPython的优缺点#\n\nPython 语言的优点很多，简单为大家列出几点。\n\n 1. 简单优雅，跟其他很多编程语言相比，Python 更容易上手。\n 2. 能用更少的代码做更多的事情，提升开发效率。\n 3. 开放源代码，拥有强大的社区和生态圈。\n 4. 能够做的事情非常多，有极强的适应性。\n 5. 胶水语言，能够黏合其他语言开发的东西。\n 6. 解释型语言，更容易跨平台，能够在多种操作系统上运行。\n\nPython 最主要的缺点是执行效率低（解释型语言的通病），如果更看重代码的执行效率，C、C++ 或 Go 可能是你更好的选择。\n\nPython的应用领域#\n\n目前 Python 在桌面应用开发、Web\n服务器开发、云基础设施开发、网络数据采集、数据分析、量化交易、机器学习、自动化等领域都有用武之地。很多一线互联网公司都使用 Python\n来开发各类支撑系统、实现自动化测试和自动化运维；还有很多公司用 Python 进行大数据处理，从数据采集、数据清洗到最终的数据呈现，Python\n都提供了完美的解决方案，帮助企业从数据中发现商业价值；此外，做量化交易尤其是高频交易的操盘手，都倾向于使用 Python 语言来接入交易系统并编写交易策略。\n\n\n安装Python环境#\n\n工欲善其事，必先利其器。想要开始你的 Python 编程之旅，首先得在计算机上安装 Python 环境，简单的说就是安装运行 Python 程序需要的\nPython 解释器。我们推荐大家安装官方的 Python 3解释器，它是用 C 语言编写的，我们通常也称之为\nCPython，它应该是你目前最好的选择。首先，我们需要从官方网站下载页面找到并下载适合自己操作系统的 Python 3安装程序，如下图所示。\n\nWindows环境#\n\n下面我们以 Windows 11为例，讲解如何在 Windows 操作系统上安装 Python\n环境。双击运行从官网下载的安装程序，会打开一个安装向导，画面如下所示。首先，一定要记得勾选“Add python.exe to PATH”选项，它会帮助我们将\nPython 解释器添加到 Windows 系统的 PATH 环境变量中（不理解没关系，勾上就对了）；其次，“Use admin privileges when\ninstalling py.exe”是为了在安装过程中获得管理员权限，建议勾选。然后，我们选择“Customize\nInstallation”，使用自定义安装的模式，这是专业人士的选择，而你就（假装）是那个专业人士，不建议使用“Install Now”（默认安装）。\n\n接下来，安装向导会提示你勾选需要的“Optional Features”（可选特性），这里咱们可以直接全选。值得一提的是其中的第2项，它是 Python\n的包管理工具 pip，可以帮助我们安装三方库和三方工具，所以一定要记得勾选它，然后点击“Next”进入下一环节。\n\n接下来是对“Advanced Options”（高级选项）的选择，这里我们建议大家只勾选“Add Python to environment\nvariables”和“Precompile standard\nlibrary”这两个选项，前者会帮助我们自动配置好环境变量，后者会预编译标准库（生成.pyc文件），这样在使用时就无需临时编译了。还是那句话，不理解没关系，勾\n上就对了。下面的“Customize install\nlocation”（自定义安装路径）强烈建议修改为自定义的路径，这个路径中不应该包含中文、空格或其他特殊字符，注意这一点会为你减少很多不必要的麻烦。设置完成后，\n点击“Install”开始安装。\n\n安装成功会出现如下图所示的画面，安装成功的关键词是“successful”，如果安装失败，这里的单词会变成“failed”。\n\n安装完成后可以打开 Windows 的“命令行提示符”或 PowerShell，然后输入python --version或python\n-V来检查安装是否成功，这个命令是查看 Python 解释器的版本号。如果看到如下所示的画面，那么恭喜你，Python\n环境已经安装成功了。这里我们建议再检查一下 Python 的包管理工具 pip 是否可用，对应的命令是pip --version或pip -V。\n\n> 说明：如果安装过程报错或提示安装失败，很有可能是你的 Windows\n> 系统缺失了一些动态链接库文件或缺少必要的构建工具导致的。可以在微软官网下载“Visual Studio 2022\n> 生成工具”进行修复，如下图所示。如果不方便在微软官网下载的，也可以使用下面的百度云盘链接来获取修复工具，链接:\n> https://pan.baidu.com/s/1iNDnU5UVdDX5sKFqsiDg5Q 提取码: cjs3。\n> \n> 上面下载的“Visual Studio 2022\n> 生成工具”需要联网才能运行，运行后会出现如下图所示的画面，大家可以参考下图勾选对应的选项进行修复。修复过程需要联网下载对应的软件包，这个过程可能会比较耗时间\n> ，修复成功后可能会要求重启你的操作系统。\n\nmacOS环境#\n\nmacOS 安装 Python 环境相较于 Windows\n系统更为简单，我们从官方下载的安装包是一个pkg文件，双击运行之后不断的点击“继续”就安装成功了，几乎不用做任何的设置和勾选，如下图所示。\n\n安装完成后，可以在 macOS 的“终端”工具中输入python3\n--version命令来检查是否安装成功，注意这里的命令是python3不是python！！！然后我们再检查一下包管理工具，输入命令pip3\n--version，如下图所示。\n\n\n总结#\n\n总结下这一课学到的东西：\n\n 1. Python 语言很强大，可以做很多的事情，也值得我们去学习。\n 2. 要使用 Python语言，首先得安装 Python 环境，也就是运行 Python 程序所需的 Python 解释器。\n 3. Windows 系统可以在命令提示符或 PowerShell 中输入python --version检查 Python 解释器的版本；macOS\n    系统可以在终端中输入python3 --version检查 Python 解释器的版本。",
    "routePath": "/tutorial/python/第01课：初识Python",
    "lang": "",
    "toc": [
      {
        "text": "第01课：初识Python",
        "id": "第01课初识python",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "Python简介",
        "id": "python简介",
        "depth": 3,
        "charIndex": 16
      },
      {
        "text": "Python的编年史",
        "id": "python的编年史",
        "depth": 4,
        "charIndex": 345
      },
      {
        "text": "Python的优缺点",
        "id": "python的优缺点",
        "depth": 4,
        "charIndex": 1073
      },
      {
        "text": "Python的应用领域",
        "id": "python的应用领域",
        "depth": 4,
        "charIndex": 1342
      },
      {
        "text": "安装Python环境",
        "id": "安装python环境",
        "depth": 3,
        "charIndex": 1601
      },
      {
        "text": "Windows环境",
        "id": "windows环境",
        "depth": 4,
        "charIndex": 1819
      },
      {
        "text": "macOS环境",
        "id": "macos环境",
        "depth": 4,
        "charIndex": 3236
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3471
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 6,
    "title": "",
    "content": "第02课：第一个Python程序#\n\n在上一课中，我们对 Python 语言的过去现在有了一些了解，我们准备好了运行 Python 程序所需要的解释器环境。相信大家已经迫不及待的想开始自己的\nPython 编程之旅了，但是新问题来了，我们应该在什么地方书写 Python 程序，然后又怎么运行它呢？\n\n\n编写和运行代码的工具#\n\n下面我们为大家讲解几种可以编写和运行 Python 代码的工具，大家可以根据自己的需求来选择合适的工具。当然，对于初学者，我个人比较推荐使用\nPyCharm，因为它不需要太多的配置也非常的强大，对新手还是很友好的。\n\n默认的交互式环境#\n\n我们打开Windows的“命令提示符”或“PowerShell”工具，输入python然后按下Enter键，这个命令会把我们带到一个交互式环境中。所谓交互式环境\n，就是我们输入一行代码并按下Enter键，代码马上会被执行，如果代码有产出结果，那么结果会被显示在窗口中，如下所示。\n\n\n\n> 说明：使用 macOS 系统的用户需要打开“终端”工具，输入python3进入交互式环境。\n\n如果希望退出交互式环境，可以在交互式环境中输入quit()，如下所示。\n\n\n\n更好的交互式环境 - IPython#\n\n上面说的交互式环境用户体验并不怎么好，大家使用一下就能清晰的感受到。我们可以用 IPython 来替换掉它，因为 IPython\n提供了更为强大的编辑和交互功能。我们可以使用 Python 的包管理工具pip来安装 IPython，如下所示。\n\n\n\n> 提示：在使用上面的命令安装 IPython 之前，可以先通过pip config set global.index-url\n> https://pypi.doubanio.com/simple命令或pip config set global.index-url\n> https://pypi.tuna.tsinghua.edu.cn/simple/将下载源修改为国内的豆瓣镜像或清华镜像，否则下载安装的过程可能会非常的缓慢\n> 。\n\n接下来可以使用下面的命令启动 IPython，进入交互式环境。\n\n\n\n> 说明：还有一个网页版的 IPython 名字叫 Jupyter，由于暂时用不上它们，我们在其他的地方再给大家介绍。\n\n文本编辑神器 - Visual Studio Code#\n\nVisual Studio Code 是由微软开发能够在 Windows、 Linux 和 macOS\n等操作系统上运行的代码编辑神器。它支持语法高亮、自动补全、多点编辑、运行调试等一系列便捷功能，而且能够支持多种编程语言。如果大家要选择一款高级文本编辑工具，强烈\n推荐 Visual Studio Code，关于它的下载、安装和使用，有兴趣的读者可以自行研究。\n\n集成开发环境 - PyCharm#\n\n如果用 Python 语言开发商业项目，我们推荐大家使用更为专业的工具 PyCharm。PyCharm 是由捷克一家名为 JetBrains 的公司针对\nPython\n语言提供的集成开发环境（IDE)。所谓集成开发环境，通常是指提供了编写代码、运行代码、调试代码、分析代码、版本控制等一系列强大功能和便捷操作的开发工具，因此特别\n适合用于商业项目的开发。我们可以在 JetBrains 公司的官方网站上找到 PyCharm 的下载链接，如下图所示。\n\n官方提供了两个 PyCharm 的版本，一个是免费的社区版（Community\nEdition），功能相对弱小，但对于初学者来说是完全够用的；另一个是付费的专业版（Professional\nEdition），功能非常强大，但需要按年或按月支付费用，新用户可以免费试用30天时间。PyCharm\n的安装没有任何难度，运行下载的安装程序，几乎全部使用默认设置进行安装就可以了，其中有一个步骤可以按照下图所示，勾选“创建桌面快捷方式”和“在右键菜单中添加\"Op\nen Folder as Project\"”就可以了。\n\n第一次运行 PyCharm 时，在提示你导入 PyCharm 设置的界面上直接选择“Do not import\nsettings”，然后我们就可以看到如下图所示的欢迎界面。此处，我们可以先点击“Customize”选项对 PyCharm 做一些个性化的设置。\n\n接下来，我们可以在“Projects”选项中点击“New\nProject”来创建一个新的项目，此处还可以“打开已有项目”或“从版本控制服务器（VCS）获取项目”，如下图所示。\n\n创建项目的时候需要指定项目的路径并创建”虚拟环境“，我们建议每个 Python 都在自己专属的虚拟环境中运行。如果你的系统上还没 Python 环境，那么\nPyCharm 会提供官网的下载链接，当你点击“Create”按钮创建项目时，它会联网下载 Python 解释器，如下图所示。\n\n当然，我们并不推荐这么做，因为我们在上一课已经安装过 Python 环境了。在系统有 Python 环境的情况下，PyCharm 通常会自动发现 Python\n解释器的位置并以此为基础创建虚拟环境，所以大家看到的画面应该如下图所示。\n\n> 说明：上面的截图来自于 Windows 系统，如果使用 macOS 系统，你看到的项目路径和 Python 解释器路径会跟上面有所不同。\n\n创建好项目后会出现如下图所示的画面，我们可以通过在项目文件夹上点击鼠标右键，选择“New”菜单下的“Python File”来创建一个 Python\n文件，在给文件命名时建议使用英文字母和下划线的组合，创建好的 Python 文件会自动打开，进入可编辑的状态。\n\n接下来，我们可以在代码窗口编写我们的 Python\n代码。写好代码后，可以在窗口中点击鼠标右键，选择“Run”菜单项来运行代码，下面的“Run”窗口会显示代码的执行结果，如下图所示。\n\n到这里，我们的第一个 Python 程序已经运转起来了，很酷吧！对了，PyCharm 有一个叫“每日小贴士”的弹窗，会教给你一些使用 PyCharm\n的小技巧，如下图所示。如果不需要，直接关闭就可以了；如果不希望它再次出现，在关闭前可以勾选“Don't show tips on startup”。\n\n\n你好世界#\n\n按照行业惯例，我们学习任何一门编程语言写的第一个程序都是输出hello, world，因为这段代码是伟大的丹尼斯·里奇（C 语言之父，和肯·汤普森一起开发了\nUnix 操作系统）和布莱恩·柯尼汉（awk 语言的发明者）在他们的不朽著作《The C Programming\nLanguage》中写的第一段代码，下面是对应的 Python 语言的版本。\n\n\n\n> 注意：上面代码中的圆括号、单引号都是在英文输入法状态下输入的，如果不小心写成了中文的圆括号或单引号，运行代码时会出现SyntaxError: invalid\n> character '（' (U+FF08)或SyntaxError: invalid character '‘' (U+2018)这样的错误提示。\n\n上面的代码只有一个语句，在这个语句中，我们用到了一个名为print的函数，它可以帮助我们输出指定的内容；print函数圆括号中的'hello,\nworld'是一个字符串，它代表了一段文本内容；在 Python 语言中，我们可以用单引号或双引号来表示一个字符串。不同于 C、C++ 或 Java\n这样的编程语言，Python 代码中的语句不需要用分号来表示结束，也就是说，如果我们想再写一条语句，只需要回车换行即可，代码如下所示。此外，Python\n代码也不需要通过编写名为main的入口函数来使其运行，提供入口函数是编写可执行的 C、C++ 或 Java 代码必须要做的事情，这一点很多程序员都不陌生，但是在\nPython 语言中它并不是必要的。\n\n\n\n如果不使用 PyCharm 这样的集成开发环境，我们也可以直接调用 Python 解释器来运行 Python\n程序。我们可以将上面的代码保存成一个名为example01.py的文件，对于Windows\n系统，我们假设该文件在C:\\code\\目录下，我们打开“命令提示符”或“PowerShell”并输入下面的命令就可以运行它。\n\n\n\n对于 macOS 系统，假设我们的文件在/Users/Hao/目录下，那么可以在终端中输入下面的命令来运行程序。\n\n\n\n> 提示：如果路径比较长，不愿意手动输入，我们可以通过拖拽的方式将文件直接拖到“命令提示符”或“终端”中，这样会自动输入完整的文件路径。\n\n大家可以试着修改上面的代码，比如将单引号中的hello, world换成其他内容或者多写几个这样的语句，看看会运行出怎样的结果。需要提醒大家的是，写\nPython 代码时，最好每一行只写一条语句。虽然，我们可以使用;作为分隔将多个语句写在一行中，但是这样做会让代码变得非常难看，不再具备良好的可读性。\n\n\n注释你的代码#\n\n注释是编程语言的一个重要组成部分，用于在代码中解释代码的作用，从而达到增强代码可读性的目标。当然，我们也可以将代码中暂时不需要运行的代码段通过添加注释来去掉，这\n样当你需要重新使用这些代码的时候，去掉注释符号就可以了。简单的说，注释会让代码更容易看懂但不会影响代码的执行结果。\n\nPython 中有两种形式的注释：\n\n 1. 单行注释：以#和空格开头，可以注释掉从#开始后面一整行的内容。\n 2. 多行注释：三个引号（通常用双引号）开头，三个引号结尾，通常用于添加多行说明性内容。\n\n\n\n\n总结#\n\n到此，我们已经把第一个 Python 程序运行起来了，是不是很有成就感？！只要你坚持学习下去，再过一段时间，我们就可以用 Python\n语言做更多更酷的事情。今时今日，编程就跟英语一样，对很多人来说都是一项必须要掌握的技能。",
    "routePath": "/tutorial/python/第02课：第一个Python程序",
    "lang": "",
    "toc": [
      {
        "text": "第02课：第一个Python程序",
        "id": "第02课第一个python程序",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "编写和运行代码的工具",
        "id": "编写和运行代码的工具",
        "depth": 3,
        "charIndex": 151
      },
      {
        "text": "默认的交互式环境",
        "id": "默认的交互式环境",
        "depth": 4,
        "charIndex": 273
      },
      {
        "text": "更好的交互式环境 - IPython",
        "id": "更好的交互式环境---ipython",
        "depth": 4,
        "charIndex": 515
      },
      {
        "text": "文本编辑神器 - Visual Studio Code",
        "id": "文本编辑神器---visual-studio-code",
        "depth": 4,
        "charIndex": 976
      },
      {
        "text": "集成开发环境 - PyCharm",
        "id": "集成开发环境---pycharm",
        "depth": 4,
        "charIndex": 1189
      },
      {
        "text": "你好世界",
        "id": "你好世界",
        "depth": 3,
        "charIndex": 2621
      },
      {
        "text": "注释你的代码",
        "id": "注释你的代码",
        "depth": 3,
        "charIndex": 3742
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3996
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 7,
    "title": "",
    "content": "第03课：Python语言中的变量#\n\n对于想学习编程的新手来说，有两个问题可能是他们很想知道的，其一是“什么是（计算机）程序”，其二是“写（计算机）程序能做什么”。先说说我对这两个问题的理解：程序是\n数据和指令的有序集合，写程序就是用数据和指令控制计算机做我们想让它做的事情。今时今日，为什么有那么多人选择用 Python 语言来写程序，因为 Python\n语言足够简单和强大。相较于 C、C++、Java 这样的编程语言，Python 对初学者和非专业人士更加友好，我们想做的很多事情，在 Python\n语言中都能找到简单优雅的解决方案。接下来，我们就从最基础的语言元素开始，带大家认识和使用 Python 语言。\n\n\n一些计算机常识#\n\n在开始系统的学习编程之前，我们先来科普一些计算机的基础知识。计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和\n控制器放在一起就是我们常说的中央处理器（CPU），它的功能是执行各种运算和控制指令。刚才我们提到过程序是指令的集合，写程序就是将一系列的指令按照某种方式组织到一\n起，然后通过这些指令去控制计算机做我们想让它做的事情。存储器可以分为内部存储器和外部存储器，前者就是我们常说的内存，它是中央处理器可以直接寻址的存储空间，程序在\n执行的过程中，对应的数据和指令需要加载到内存中。输入设备和输出设备经常被统称为 I/O\n设备，键盘、鼠标、麦克风、摄像头是典型的输入设备，而显示器、打印机、扬声器等则是典型的输出设备。目前，我们使用的计算机基本都是遵循“冯·诺依曼体系结构”的计算机\n，这种计算机有两个关键点：一是将存储器与中央处理器分开；二是将数据以二进制方式编码。\n\n二进制是一种“逢二进一”的计数法，跟人类使用的“逢十进一”的计数法本质是一样的。人类因为有十根手指，所以使用了十进制计数法，在计数时十根手指用完之后，就只能用进\n位的方式来表示更大的数值。当然凡事都有例外，玛雅人可能是因为长年光着脚的原因，把脚趾头也都用上了，于是他们使用了二十进制的计数法。基于这样的计数方式，玛雅人使用\n的历法跟我们平常使用的历法就产生了差异。按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始。后来这件事情还被以\n讹传讹的方式误传为“2012年是玛雅人预言的世界末日”的荒诞说法。今天有很多人猜测，玛雅文明之所以发展缓慢跟使用了二十进制是有关系的。对于计算机来说，二进制在物\n理器件上最容易实现的，因为可以用高电压表示1，用低电压表示0。不是所有写程序的人都需要熟悉二进制，熟悉十进制与二进制、八进制、十六进制的转换，大多数时候我们即便\n不了解这些知识也能写程序。但是，我们必须知道，计算机是使用二进制计数的，不管什么样的数据，到了计算机内存中都是以二进制形态存在的。\n\n> 说明：关于二进制计数法以及它与其他进制如何相互转换，随便找本名为《计算机导论》或《计算机文化》的书，都能找到相应的知识，此处就不再进行赘述了，不清楚的读者可\n> 以自行研究。\n\n\n变量和类型#\n\n要想在计算机的内存中保存数据，首先得说一说变量这个概念。在编程语言中，变量是数据的载体，简单的说就是一块用来保存数据的内存空间，变量的值可以被读取和修改，这是所\n有运算和控制的基础。计算机能处理的数据有很多种类型，最常见的就是数值，除了数值之外还有文本、图像、音频、视频等各种各样的数据类型。虽然数据在计算机中都是以二进制\n形态存在的，但是我们可以用不同类型的变量来表示数据类型的差异。Python\n语言中预设了多种数据类型，也允许我们自定义新的数据类型，这一点在后面会讲到。我们首先来了解几种 Python 中最为常用的数据类型。\n\n 1. 整型（int）：Python\n    中可以处理任意大小的整数，而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x\n    100，换算成十进制是256）的表示法。运行下面的代码，看看会输出什么。\n    \n    \n\n 2. 浮点型（float）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.45\n    6）之外还支持科学计数法（如1.23456e2，表示$\\small{1.23456 \\times 10^{2}}$）。运行下面的代码，看看会输出什么。\n    \n    \n\n 3. 字符串型（str）：字符串是以单引号或双引号包裹起来的任意文本，比如'hello'和\"hello\"。\n\n 4. 布尔型（bool）：布尔型只有True、False两种值，要么是True，要么是False，可以用来表示现实世界中的“是”和“否”，命题的“真”和“假”\n    ，状况的“好”与“坏”，水平的“高”与“低”等等。如果一个变量的值只有两种状态，我们就可以使用布尔型。\n\n\n变量命名#\n\n对于每个变量，我们都需要给它取一个名字，就如同我们每个人都有自己的名字一样。在 Python 中，变量命名需要遵循以下的规则和惯例。\n\n * 规则部分：\n   * 规则1：变量名由字母、数字和下划线构成，数字不能开头。需要说明的是，这里说的字母指的是 Unicode 字符，Unicode\n     称为万国码，囊括了世界上大部分的文字系统，这也就意味着中文、日文、希腊字母等都可以作为变量名中的字符，但是一些特殊字符（如：！、@、#等）是不能出现在\n     变量名中的。我们强烈建议大家把这里说的字母理解为尽可能只使用英文字母。\n   * 规则2：Python 是大小写敏感的编程语言，简单的说就是大写的A和小写的a是两个不同的变量，这一条其实并不算规则，而是需要大家注意的地方。\n   * 规则3：变量名不要跟 Python 的关键字重名，尽可能避开 Python 的保留字。这里的关键字是指在 Python\n     程序中有特殊含义的单词（如：is、if、else、for、while、True、False等），保留字主要指 Python\n     语言内置函数、内置模块等的名字（如：int、print、input、str、math、os等）。\n * 惯例部分：\n   * 惯例1：变量名通常使用小写英文字母，多个单词用下划线进行连接。\n   * 惯例2：受保护的变量用单个下划线开头。\n   * 惯例3：私有的变量用两个下划线开头。\n\n惯例2和惯例3大家暂时不用理解，讲到后面自然会明白的。当然，作为一个专业的程序员，给变量命名时做到见名知意也是非常重要，这彰显了一个程序员的专业气质，很多开发岗\n位的面试也非常看重这一点。\n\n\n变量的使用#\n\n下面通过例子来说明变量的类型和变量的使用。\n\n\n\n在 Python\n中可以使用type函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念非常类似，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂\n时不理解函数这个概念也不要紧，我们会在后续的内容中专门讲解函数的定义和使用。\n\n\n\n可以通过 Python 内置的函数来改变变量的类型，下面是一些常用的和变量类型相关的函数。\n\n * int()：将一个数值或字符串转换成整数，可以指定进制。\n * float()：将一个字符串（在可能的情况下）转换成浮点数。\n * str()：将指定的对象转换成字符串形式，可以指定编码方式。\n * chr()：将整数（字符编码）转换成对应的（一个字符的）字符串。\n * ord()：将（一个字符的）字符串转换成对应的整数（字符编码）。\n\n下面的例子为大家演示了Python中类型转换的操作。\n\n\n\n> 说明：str类型转int类型时可以通过base参数来指定进制，可以将字符串视为对应进制的整数进行转换。str类型转成bool类型时，只要字符串有内容，不是'\n> '或\"\"，对应的布尔值都是True。bool类型转int类型时，True会变成1，False会变成0。在 ASCII 字符集和 Unicode 字符集中，\n> 字符'd'对应的编码都是100。\n\n\n总结#\n\n在 Python 程序中，我们可以使用变量来保存数据，变量有不同的类型，常用的类型有int、float、str和bool。在有需要的情况下，可以通过\nPython 内置的函数对变量进行类型转换。变量是可以做运算的，这是解决很多问题的先决条件，我们会在下一课中为大家详细介绍变量的运算。",
    "routePath": "/tutorial/python/第03课：Python语言中的变量",
    "lang": "",
    "toc": [
      {
        "text": "第03课：Python语言中的变量",
        "id": "第03课python语言中的变量",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "一些计算机常识",
        "id": "一些计算机常识",
        "depth": 3,
        "charIndex": 311
      },
      {
        "text": "变量和类型",
        "id": "变量和类型",
        "depth": 3,
        "charIndex": 1297
      },
      {
        "text": "变量命名",
        "id": "变量命名",
        "depth": 3,
        "charIndex": 2092
      },
      {
        "text": "变量的使用",
        "id": "变量的使用",
        "depth": 3,
        "charIndex": 2821
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3418
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 8,
    "title": "",
    "content": "第04课：Python语言中的运算符#\n\nPython 语言支持很多种运算符，下面的表格按照运算符的优先级从高到低，对 Python\n中的运算符进行了罗列。有了变量和运算符，我们就可以构造各种各样的表达式来解决实际问题。在计算机科学中，表达式是计算机程序中的句法实体，它由一个或多个常量、变量、\n函数和运算符组合而成，编程语言可以对其进行解释和计算以得到另一个值。不管使用什么样的编程语言，构造表达式都是非常重要的。\n\n运算符                             描述\n[]、[:]                          索引、切片\n**                              幂\n~、+、-                           按位取反、正号、负号\n*、/、%、//                        乘、除、模、整除\n+、-                             加、减\n>>、<<                           右移、左移\n&                               按位与\n^、`                             `\n<=、<、>、>=                       小于等于、小于、大于、大于等于\n==、!=                           等于、不等于\nis、is not                       身份运算符\nin、not in                       成员运算符\nnot、or、and                      逻辑运算符\n=、+=、-=、*=、/=、%=、//=、**=、&=、`   =、^=、>>=、<<=`\n\n> 说明：\n> 所谓优先级就是在一个运算的表达式中，如果出现了多个运算符，应该先执行什么再执行什么的顺序。编写代码的时候，如果搞不清楚一个表达式中运算符的优先级，可以使用圆\n> 括号来确保运算的执行顺序。\n\n\n算术运算符#\n\nPython\n中的算术运算符非常丰富，除了大家最为熟悉的加、减、乘、除之外，还有整除运算符、求模（求余数）运算符和求幂运算符。下面的例子为大家展示了算术运算符的使用。\n\n\n\n算术运算需要先乘除后加减，这一点跟数学课本中讲的知识没有区别，也就是说乘除法的运算优先级是高于加减法的。如果还有求幂运算，求幂运算的优先级是高于乘除法的。如果想\n改变算术运算的执行顺序，可以使用英文输入法状态下的圆括号（小括号），写在圆括号中的表达式会被优先执行，如下面的例子所示。\n\n\n\n\n赋值运算符#\n\n赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。赋值运算符还可以跟上面的算术运算符放在一起，组合成复合赋值运算符，例如：a +=\nb相当于a = a + b，a *= a + 2相当于a = a * (a + 2)。下面的例子演示了赋值运算符和复合赋值运算符的使用。\n\n\n\n> 注意：赋值运算构成的表达式本身不产生任何值，为了解决这个问题，Python\n> 3.8中引入了一个新的赋值运算符:=，我们通常称之为海象运算符，大家可以猜一猜它为什么叫这个名字，我们在后面用到的时候再为大家讲解这个运算符。\n\n\n比较运算符和逻辑运算符#\n\n比较运算符也称为关系运算符，包括==、!=、<、>、<=、>=，我相信大家一看就能懂。需要提醒的是比较相等用的是==，请注意这里是两个等号，因为=是赋值运算符，\n我们在上面刚刚讲到过。比较不相等用的是!=，跟数学课本中使用的$\\small{\\neq}$并不相同，Python 2中曾经使用过<>来表示不等于，在\nPython 3中使用<>会引发SyntaxError（语法错误）。比较运算符会产生布尔值，要么是True，要么是False。\n\n逻辑运算符有三个，分别是and、or和not。and字面意思是“而且”，所以and运算符会连接两个布尔值或者产生布尔值的表达式，如果两边的布尔值都是True，那\n么运算的结果就是True；左右两边的布尔值有一个是False，最终的运算结果就是False。当然，如果and运算符左边的布尔值是False，不管右边的布尔值是什\n么，最终的结果都是False，这时运算符右边的布尔值会被跳过（专业的说法叫短路处理，如果and右边是一个表达式，那么这个表达式不会执行）。or字面意思是“或者”\n，所以or运算符也会连接两个布尔值或产生布尔值的表达式，如果两边的布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，当它\n左边的布尔值为True的情况下，右边的布尔值会被短路（如果or右边是一个表达式，那么这个表达式不会执行）。not运算符的后面可以跟一个布尔值，如果not后面的布\n尔值或表达式是True，那么运算的结果就是False；如果not后面的布尔值或表达式是False，那么运算的结果就是True。\n\n\n\n> 说明：比较运算符的优先级高于赋值运算符，所以上面的flag0 = 1 == 1先做1 ==\n> 1产生布尔值True，再将这个值赋值给变量flag0。print函数可以输出多个值，多个值之间可以用,进行分隔，输出的内容默认以空格分开。\n\n\n运算符和表达式应用举例#\n\n例子1：华氏温度转摄氏温度#\n\n要求：输入华氏温度将其转换为摄氏温度，华氏温度到摄氏温度的转换公式为：$\\small{C = (F - 32) / 1.8}$。\n\n\n\n> 说明：上面代码中的input函数用于从键盘接收用户输入，由于输入的都是字符串，如果想处理成浮点小数来做后续的运算，可以用我们上一课讲解的类型转换的方法，用f\n> loat函数将str类型处理成float类型。\n\n上面的代码中，我们对print函数输出的内容进行了格式化处理，print输出的字符串中有两个%.1f占位符，这两个占位符会被%之后的(f,\nc)中的两个float类型的变量值给替换掉，浮点数小数点后保留1位有效数字。如果字符串中有%d占位符，那么我们会用int类型的值替换掉它，如果字符串中有%s占位\n符，那么它会被str类型的值替换掉。\n\n除了上面格式化输出的方式外，Python\n中还可以用下面的办法来格式化输出，我们给出一个带占位符的字符串，字符串前面的f表示这个字符串是需要格式化处理的，其中的{f:.1f}和{c:.1f}可以先看成是\n{f}和{c}，表示输出时会用变量f和变量c的值替换掉这两个占位符，后面的:.1f表示这是一个浮点数，小数点后保留1位有效数字。\n\n\n\n例子2：计算圆的周长和面积#\n\n要求：输入一个圆的半径，计算出它的周长（$\\small{2 \\pi r}$）和面积（$\\small{\\pi r^{2}}$）。\n\n\n\nPython 中有一个名为math 的内置模块，该模块中定义了名为pi的变量，它的值就是圆周率。如果要使用 Python\n内置的这个pi，我们可以对上面的代码稍作修改。\n\n\n\n> 说明：上面代码中的import math表示导入math模块，导入该模块以后，才能用math.pi得到圆周率的值。\n\n这里其实还有一种格式化输出的方式，是 Python 3.8 中增加的新特性，大家直接看下面的代码就明白了。\n\n\n\n> 说明：假如变量a的值是9.87，那么字符串f'{a = }'的值是a = 9.87；而字符串f'{a = :.1f}'的值是a =\n> 9.9。这种格式化输出的方式会同时输出变量名和变量值。\n\n例子3：判断闰年#\n\n要求：输入一个1582年以后的年份，判断该年份是不是闰年。\n\n\n\n> 说明：对于格里历（Gregorian calendar），即今天我们使用的公历，判断闰年的规则是：1. 公元年份非4的倍数是平年；2.\n> 公元年份为4的倍数但非100的倍数是闰年；3.\n> 公元年份为400的倍数是闰年。格里历是由教皇格里高利十三世在1582年10月引入的，作为对儒略历（Julian\n> calendar）的修改和替代，我们在输入年份时要注意这一点。上面的代码通过%来判断year是不是4的倍数、100的倍数、400的倍数，然后用and和or运\n> 算符将三个条件组装在一起，前两个条件要同时满足，第三个条件跟前两个条件的组合只需满足其中之一。\n\n\n总结#\n\n通过上面的讲解和例子，相信大家已经感受到了运算符和表达式的力量。实际编程中的很多问题，都需通过构造表达式来解决，所以变量、运算符、表达式对于任何一门编程语言都是\n极为重要的基础。如果本节课的内容有什么不理解的地方，一定不要着急进入下一课，先在评论区留言讨论，我会及时解答大家的问题。",
    "routePath": "/tutorial/python/第04课：Python语言中的运算符",
    "lang": "",
    "toc": [
      {
        "text": "第04课：Python语言中的运算符",
        "id": "第04课python语言中的运算符",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "算术运算符",
        "id": "算术运算符",
        "depth": 3,
        "charIndex": 897
      },
      {
        "text": "赋值运算符",
        "id": "赋值运算符",
        "depth": 3,
        "charIndex": 1138
      },
      {
        "text": "比较运算符和逻辑运算符",
        "id": "比较运算符和逻辑运算符",
        "depth": 3,
        "charIndex": 1410
      },
      {
        "text": "运算符和表达式应用举例",
        "id": "运算符和表达式应用举例",
        "depth": 3,
        "charIndex": 2239
      },
      {
        "text": "例子1：华氏温度转摄氏温度",
        "id": "例子1华氏温度转摄氏温度",
        "depth": 4,
        "charIndex": 2253
      },
      {
        "text": "例子2：计算圆的周长和面积",
        "id": "例子2计算圆的周长和面积",
        "depth": 4,
        "charIndex": 2786
      },
      {
        "text": "例子3：判断闰年",
        "id": "例子3判断闰年",
        "depth": 4,
        "charIndex": 3174
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3505
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 9,
    "title": "",
    "content": "第05课：分支结构#\n\n迄今为止，我们写的 Python\n代码都是一条一条语句按顺序向下执行的，这种代码结构叫做顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的过关条件是玩家获得100\n0分，那么在第一关完成后，我们要根据玩家得到分数来决定是进入第二关，还是告诉玩家“Game\nOver”。在这样的场景下，我们的代码就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大\n家一分钟的时间，你应该可以想到至少5个以上类似的例子，赶紧试一试吧！\n\n\n使用if和else构造分支结构#\n\n在 Python\n中，要构造分支结构可以使用if、elif和else三个关键字。所谓关键字就是编程语言中有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然\n你不能够使用它作为变量名。当然，我们并不是每次构造分支结构都会把三个关键字全部用上，下面我们通过例子加以说明。\n\n我们来写一个身体质量指数（BMI）的计算器。身体质量质数也叫体质指数，是国际上常用的衡量人体胖瘦程度以及是否健康的一个标准，计算公式如下所示。通常认为$\\sma\nll{18.5 \\le BMI < 24}$是正常范围，$\\small{BMI < 18.5}$说明体重过轻，$\\small{BMI \\ge\n24}$说明体重过重，$\\small{BMI \\ge 27}$就属于肥胖的范畴了。\n\n$$ BMI = \\frac{体重}{身高^{2}} $$\n\n> 说明：上面公式中的体重以千克（kg）为单位，身高以米（m）为单位。\n\n\n\n> 提示：if语句的最后面有一个:，它是用英文输入法输入的冒号；程序中输入的'、\"、=、(、)等特殊字符，都是在英文输入法状态下输入的，这一点之前已经提醒过大家\n> 了。很多初学者经常会忽略这一点，等到执行代码时，就会看到一大堆错误提示。当然，认真读一下错误提示还是很容易发现哪里出了问题，但是强烈建议大家在写代码的时候切\n> 换到英文输入法，这样可以避免很多不必要的麻烦。\n\n上面的代码中，我们在计算和输出 BMI 之后，加上了一段分支结构，如果满足$\\small{18.5 \\le BMI <\n24}$，程序会输出“你的身材很棒！”，但是如果不满足条件，这段输出就没有了。这就是我们上面说的代码有不同的执行路径，有些代码不一定会执行到。我们在if关键字的\n后面给出了一个表达式18.5 <= bmi <\n24，之前我们说过，关系运算会产生布尔值，如果if后面的布尔值为True，那么if语句下方，有四个空格缩进的print('你的身材很棒！')就会被执行。我们先输\n入几组数据运行上面的代码，如下所示。\n\n第一组输入：\n\n\n\n第二组输入：\n\n\n\n第三组输入：\n\n\n\n只有第一组输入的身高和体重计算出的 BMI 在18.5到24这个范围值内，所以触发了if条件，输出了“你的身材很棒”。需要说明的是，不同于 C、C++、Java\n等编程语言，Python\n中没有用花括号来构造代码块而是使用缩进的方式来表示代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说，若\n干行连续的语句如果保持了相同的缩进，那么它们就属于同一个代码块，相当于是一个执行的整体。缩进可以使用任意数量的空格，但通常使用4个空格，强烈建议大家不要使用制表\n键（Tab键）来缩进代码，如果你已经习惯了这么做，可以设置你的代码编辑器自动将1个制表键变成4个空格，很多代码编辑器都支持这项功能，PyCharm\n中默认也是这样设定的。还有一点，在 C、C++、Java 等编程语言中，18.5 <= bmi < 24要写成两个条件bmi >= 18.5和bmi <\n24，然后把两个条件用逻辑与运算符连接起来，Python 中也可以这么做，例如刚才的if语句也可以写成if bmi >= 18.5 and bmi <\n24:，但是没有必要，难道if 18.5 <= bmi < 24:这个写法它不香吗？下面用 Java 代码做了同样的事情，看不懂 Java\n代码没关系，感受一下它和 Python 语法的区别就可以了。\n\n\n\n> 说明：上面就是 BMI 计算器1.0版本对应的Java代码，欢迎在评论区吐槽它。\n\n接下来，我们对上面的代码稍作修改，在 BMI 不满足$\\small{18.5 \\le BMI <\n24}$的情况下，也给出相信的提示信息。我们可以在if代码块的后面增加一个else代码块，它会在if语句给出的条件没有达成时执行，如下所示。很显然，if下面的p\nrint('你的身材很棒！')和else下面的print('你的身材不够标准哟！')只有一个会被执行到。\n\n\n\n如果要给出更为准确的提示信息，我们可以再次修改上面的代码，通过elif关键字为上面的分支结构增加更多的分支，如下所示。\n\n\n\n我们再用刚才的三组数据来测试下上面的代码，看看会得到怎样的结果。\n\n第一组输入：\n\n\n\n第二组输入：\n\n\n\n第三组输入：\n\n\n\n\n使用math和case构造分支结构#\n\nPython 3.10 中增加了一种新的构造分支结构的方式，通过使用match和case 关键字，我们可以轻松的构造出多分支结构。Python\n的官方文档在介绍这个新语法时，举了一个 HTTP 响应状态码识别的例子，非常有意思。如果不知道什么是 HTTP 响应状态吗，可以看看 MDN\n上面的文档。下面我们对官方文档上的示例稍作修改，为大家讲解这个语法，先看看下面用if-else结构实现的代码。\n\n\n\n运行结果：\n\n\n\n下面是使用match-case语法实现的代码，虽然作用完全相同，但是代码显得更加简单优雅。\n\n\n\n> 说明：带有_的case语句在代码中起到通配符的作用，如果前面的分支都没有匹配上，代码就会来到case _。case\n> _的使用是可选的，并非每种分支结构都要给出通配符选项。如果分支中出现了case\n> _，它只能放在分支结构的最后面，如果它的后面还有其他的分支，那么这些分支将是不可达的。\n\n当然，match-case语法还有很多高级玩法，我们等用到时候再为大家讲解，有一个合并模式可以在这里分享给大家。例如，我们要将响应状态码401、403和404归\n入一个分支，400和405归入到一个分支，其他保持不变，代码还可以这么写。\n\n\n\n运行结果：\n\n\n\n\n分支结构应用举例#\n\n例子1：分段函数求值#\n\n有如下所示的分段函数，要求输入x，计算出y。 $$ y = \\begin{cases} 3x - 5, & (x \\gt 1) \\ x + 2, & (-1\n\\le x \\le 1) \\ 5x + 3, & (x \\lt -1) \\end{cases} $$\n\n\n\n根据实际开发的需要，分支结构是可以嵌套的，也就是说在分支结构的if、elif或else代码块中还可以再次引入分支结构。例如if条件成立表示玩家过关，但过关以后还\n要根据你获得宝物或者道具的数量对你的表现给出评价（比如点亮一颗、两颗或三颗星星），那么我们就需要在if的内部再构造一个新的分支结构。同理，我们在elif和els\ne中也可以构造新的分支，我们称之为嵌套的分支结构。按照这样的思路，上面的分段函数求值也可以用下面的代码来实现。\n\n\n\n> 说明：大家可以自己感受和评判一下上面两种写法哪一种更好。在Python之禅中有这么一句话：“Flat is better than\n> nested”。之所以认为“扁平化”的代码更好，是因为代码嵌套的层次如果很多，会严重的影响代码的可读性。所以，我认为上面的代码第一种写法是更好的选择。\n\n例子2：百分制成绩转换为等级制成绩#\n\n要求：如果输入的成绩在90分以上（含90分），则输出A；输入的成绩在80分到90分之间（不含90分），则输出B；输入的成绩在70分到80分之间（不含80分），则\n输出C；输入的成绩在60分到70分之间（不含70分），则输出D；输入的成绩在60分以下，则输出E。\n\n\n\n例子3：计算三角形的周长和面积。#\n\n要求：输入三条边的长度，如果能构成三角形就计算周长和面积；否则给出“不能构成三角形”的提示。\n\n\n\n> 说明： 上面的if\n> 条件表示任意两边之和大于第三边，这是构成三角形的必要条件。当这个条件成立时，我们要计算并输出周长和面积，所以if下方有五条语句都保持了相同的缩进，它们是一个\n> 整体，只要if条件成立，它们都会被执行，这就是我们之前提到的代码块的概念。另外，上面计算三角形面积的公式叫做海伦公式，假设有一个三角形，边长分别为$\\sma\n> ll{a}$、$\\small{b}$、$\\small{c}$，那么三角的面积$\\small{A}$可以由下面的公式得到，其中，$\\small{s=\\frac\n> {a+b+c}{2}}$。 $$ A = \\sqrt{s(s-a)(s-b)(s-c)} $$\n\n\n总结#\n\n学会了 Python\n中的分支结构和循环结构，我们就可以解决很多实际的问题了。这一节课相信已经帮助大家掌握了构造分支结构的方法，下一节课我们为大家介绍循环结构，学完这两次课你一定会发\n现，你能写出很多很有意思的代码，继续加油吧！",
    "routePath": "/tutorial/python/第05课：分支结构",
    "lang": "",
    "toc": [
      {
        "text": "第05课：分支结构",
        "id": "第05课分支结构",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "使用if和else构造分支结构",
        "id": "使用if和else构造分支结构",
        "depth": 3,
        "charIndex": 273
      },
      {
        "text": "使用math和case构造分支结构",
        "id": "使用math和case构造分支结构",
        "depth": 3,
        "charIndex": 2133
      },
      {
        "text": "分支结构应用举例",
        "id": "分支结构应用举例",
        "depth": 3,
        "charIndex": 2694
      },
      {
        "text": "例子1：分段函数求值",
        "id": "例子1分段函数求值",
        "depth": 4,
        "charIndex": 2705
      },
      {
        "text": "例子2：百分制成绩转换为等级制成绩",
        "id": "例子2百分制成绩转换为等级制成绩",
        "depth": 4,
        "charIndex": 3219
      },
      {
        "text": "例子3：计算三角形的周长和面积。",
        "id": "例子3计算三角形的周长和面积",
        "depth": 4,
        "charIndex": 3373
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3749
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 10,
    "title": "",
    "content": "第06课：循环结构#\n\n我们在写程序的时候，极有可能遇到需要重复执行某条指令或某些指令的场景，例如我们需要每隔1秒钟在屏幕上输出一次“hello,\nworld”并持续输出一个小时。如下所示的代码可以完成一次这样的操作，如果要持续输出一个小时，我们就需要把这段代码写3600遍，你愿意这么做吗？\n\n\n\n> 说明：Python 内置time模块的sleep函数可以实现程序的休眠，参数1表示休眠的秒数，可以使用int或float类型，例如0.05表示50毫秒。\n\n为了应对上述场景，我们可以在 Python\n程序中使用循环结构。所谓循环结构，就是程序中控制某条或某些指令重复执行的结构。有了这样的结构，刚才的代码就不需要写3600遍，而是写一遍然后放到循环结构中重复3\n600次。在 Python 语言中构造循环结构有两种做法，一种是for-in循环，另一种是while循环。\n\n\nfor-in循环#\n\n如果明确知道循环执行的次数，我们推荐使用for-in循环，例如上面说的那个重复3600次的场景，我们可以用下面的代码来实现。\n注意，被for-in循环控制的代码块也是通过缩进的方式来构造，这一点跟分支结构中构造代码块的做法是一样的。我们被for-in循环控制的代码块称为循环体，通常循环\n体中的语句会根据循环的设定被重复执行。\n\n\n\n需要说明的是，上面代码中的range(3600)可以构造出一个从0到3599的范围，当我们把这样一个范围放到for-in循环中，就可以通过前面的循环变量i依次取\n出从0到3599的整数，这就让for-in代码块中的语句可以重复3600次。当然，range的用法非常灵活，下面的清单给出了使用range函数的例子：\n\n * range(101)：可以用来产生0到100范围的整数，需要注意的是取不到101。\n * range(1, 101)：可以用来产生1到100范围的整数，相当于是左闭右开的设定，即[1, 101)。\n * range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长（跨度），即每次递增的值，101取不到。\n * range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长（跨度），即每次递减的值，0取不到。\n\n大家可能已经注意到了，上面的输出和休眠操作都没有用到循环变量i，对于不需要用到循环变量的for-in循环结构，按照 Python\n的编程惯例，我们通常把循环变量命名为_，修改后的代码如下所示。虽然结果没什么变化，但是这样写显得你更专业。\n\n\n\n上面的代码要执行一个小时，如果想提前结束程序，在 PyCharm\n中可以点击运行窗口上的停止按钮，如下图所示。如果在命令提示符或终端中运行代码，可以使用组合键ctrl+c来终止程序。\n\n下面，我们用for-in循环实现从1到100的整数求和，即$\\small{\\sum_{n=1}^{100}n}$。\n\n\n\n上面的代码中，变量total的作用是保存累加的结果。在循环的过程中，循环变量i的值会从1一直取到100。对于变量i的每个取值，我们都执行了total +=\ni，它相当于total = total + i，这条语句实现了累加操作。所以，当循环结束，我们输出变量total\n的值，它的值就是从1累加到100的结果5050。注意，print(total)这条语句前是没有缩进的，它不受for-in循环的控制，不会重复执行。\n\n我们再来写一个从1到100偶数求和的代码，如下所示。\n\n\n\n> 说明：上面的for-in循环中我们使用了分支结构来判断循环变量i是不是偶数。\n\n我们也可以修改range函数的参数，将起始值和跨度修改为2，用更为简单的代码实现从1到100的偶数求和。\n\n\n\n当然， 更为简单的办法是使用 Python 内置的sum函数求和，这样我们连循环结构都省掉了。\n\n\n\n\nwhile循环#\n\n如果要构造循环结构但是又不能确定循环重复的次数，我们推荐使用while循环。while循环通过布尔值或能产生布尔值的表达式来控制循环，当布尔值或表达式的值为Tr\nue时，循环体（while语句下方保持相同缩进的代码块）中的语句就会被重复执行，当表达式的值为False时，结束循环。\n\n下面我们用while循环来实现从1到100的整数求和，代码如下所示。\n\n\n\n相较于for-in循环，上面的代码我们在循环开始前增加了一个变量i，我们使用这个变量来控制循环，所以while后面给出了i <=\n100的条件。在while的循环体中，我们除了做累加，还需要让变量i的值递增，所以我们添加了i +=\n1这条语句，这样i的值就会依次取到1、2、3、……，直到101。当i变成101时，while循环的条件不再成立，代码会离开while循环，此时我们输出变量tot\nal的值，它就是从1到100求和的结果5050。\n\n如果要实现从1到100的偶数求和，我们可以对上面的代码稍作修改。\n\n\n\n\nbreak和continue#\n\n我们再来看一个极端的场景，把while循环的条件直接设置为布尔值True，还是从1到100的偶数求和。\n\n\n\n上面的代码中使用while\nTrue构造了一个条件恒成立的循环，也就意味着如果不做特殊处理，循环是不会结束的，这也就是常说的“死循环”。为了在i的值超过100后让循环停下来，我们使用了br\neak关键字，它的作用是终止循环结构的执行。需要注意的是，break只能终止它所在的那个循环，这一点在使用嵌套循环结构时需要引起注意，后面我们会讲到什么是嵌套的\n循环结构。除了break之外，还有另一个在循环结构中可以使用的关键字continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮，代码如下所示。\n\n\n\n> 说明：上面的代码使用continue关键字跳过了i是奇数的情况，只有在i是偶数的前提下，才会执行到total += i。\n\n\n嵌套的循环结构#\n\n和分支结构一样，循环结构也是可以嵌套的，也就是说在循环结构中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个乘法口诀表（九九表）。\n\n\n\n上面的代码中，for-in循环的循环体中又用到了for-in循环，外面的循环用来控制产生i行的输出，而里面的循环则用来控制在一行中输出j列。显然，里面的for-\nin循环的输出就是乘法口诀表中的一整行。所以在里面的循环完成时，我们用了一个print()来实现换行的效果，最后的输出如下所示。\n\n\n\n\n循环结构应用举例#\n\n例子1：判断素数#\n\n要求：输入一个大于1的正整数，判断它是不是素数。\n\n> 提示：素数指的是只能被1和自身整除的大于1的整数。例如对于正整数n，我们可以通过在2到n-1之间寻找有没有n的因子，来判断它到底是不是一个素数。当然，循环不\n> 用从2开始到n-1结束，因为对于大于1的正整数，因子应该都是成对出现的，所以循环到$\\small{\\sqrt{n}}$就可以结束了。\n\n\n\n> 说明：上面的代码中我们用了布尔型的变量is_prime，我们先将它赋值为True，假设num是一个素数；接下来，我们在2到num **\n> 0.5的范围寻找num的因子，如果找到了num的因子，那么它一定不是素数，此时我们将is_prime赋值为False，同时使用break关键字终止循环结构；\n> 最后，我们根据is_prime的值是True还是False来给出不同的输出。\n\n例子2：最大公约数#\n\n要求：输入两个大于0的正整数，求两个数的最大公约数。\n\n> 提示：两个数的最大公约数是两个数的公共因子中最大的那个数。\n\n\n\n> 说明：上面代码中for-in循环的循环变量值是从大到小的，这样我们找到的能够同时整除x和y的因子i，就是x和y的最大公约数，此时我们用break终止循环。如\n> 果x和y互质，那么循环会执行到i变成1，因为1是所有正整数的因子，此时x和y的最大公约数就是1。\n\n用上面代码的找最大公约数在执行效率是有问题的。假如x的值是999999999998，y的值是999999999999，很显然两个数是互质的，最大公约数为1。但是\n我们使用上面的代码，循环会重复999999999998次，这通常是难以接受的。我们可以使用欧几里得算法（辗转相除法）来找最大公约数，它能帮我们更快的得到想要的结\n果，代码如下所示。\n\n\n\n> 说明：解决问题的方法和步骤可以称之为算法，对于同一个问题，我们可以设计出不同的算法，不同的算法在存储空间的占用和执行效率上都会存在差别，而这些差别就代表了算\n> 法的优劣。大家可以对比上面的两段待会，体会一下为什么我们说欧几里得算法是更好的选择。上面的代码中x, y = y % x, x语句表示将y %\n> x的值赋给x，将x 原来的值赋给y。\n\n例子3：猜数字小游戏#\n\n要求：计算机出一个1到100之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息“大一点”、“小一点”或“猜对了”，如果玩家猜中了数字，计算机提示用户一\n共猜了多少次，游戏结束，否则游戏继续。\n\n\n\n> 说明：上面的代码使用import random导入了 Python\n> 标准库的random模块，该模块的randrange函数帮助我们生成了1到100范围的随机数。变量counter用来记录循环执行的次数，也就是用户一共做出了\n> 几次猜测，每循环一次counter的值都会加1。\n\n\n总结#\n\n学会了 Python\n中的分支结构和循环结构，我们就可以解决很多实际的问题了。通过这节课的学习，大家应该已经知道了可以用for和while关键字来构造循环结构。如果事先知道循环结构重\n复的次数，我们通常使用for循环；如果循环结构的重复次数不能确定，可以用while循环。此外，我们可以在循环结构中使用break终止循环，也可以在循环结构中使用\ncontinue关键字让循环结构直接进入下一轮次。",
    "routePath": "/tutorial/python/第06课：循环结构",
    "lang": "",
    "toc": [
      {
        "text": "第06课：循环结构",
        "id": "第06课循环结构",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "for-in循环",
        "id": "for-in循环",
        "depth": 3,
        "charIndex": 388
      },
      {
        "text": "while循环",
        "id": "while循环",
        "depth": 3,
        "charIndex": 1617
      },
      {
        "text": "break和continue",
        "id": "break和continue",
        "depth": 3,
        "charIndex": 2067
      },
      {
        "text": "嵌套的循环结构",
        "id": "嵌套的循环结构",
        "depth": 3,
        "charIndex": 2461
      },
      {
        "text": "循环结构应用举例",
        "id": "循环结构应用举例",
        "depth": 3,
        "charIndex": 2698
      },
      {
        "text": "例子1：判断素数",
        "id": "例子1判断素数",
        "depth": 4,
        "charIndex": 2709
      },
      {
        "text": "例子2：最大公约数",
        "id": "例子2最大公约数",
        "depth": 4,
        "charIndex": 3092
      },
      {
        "text": "例子3：猜数字小游戏",
        "id": "例子3猜数字小游戏",
        "depth": 4,
        "charIndex": 3652
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3915
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 11,
    "title": "",
    "content": "第07课：分支结构和循环结构的应用#\n\n通过前面两节课的学习，大家对 Python\n中的分支结构和循环结构已经有了初步的认知。分支结构和循环结构是构造程序逻辑的基础，它们的重要性不言而喻，但是对于初学者来说这也是比较困难的部分。很多人对分支结构\n和循环结构的语法是能够理解的，但是遇到实际问题的时候又无法下手；看懂别人的代码很容易，但是要自己写出类似的代码却又很难。如果你也有同样的问题和困惑，千万不要沮丧\n，这只是因为你的编程之旅才刚刚开始，你的练习量还没有达到让你可以随心所欲的写出代码的程度，只要加强编程练习，通过量的积累来产生质的变化，这个问题迟早都会解决的。\n\n\n经典小案例#\n\n例子1：100以内的素数#\n\n> 说明：素数指的是只能被1和自身整除的正整数（不包括1），之前我们写过判断素数的代码，这里相当于是一个升级版本。\n\n\n\n例子2：斐波那契数列#\n\n要求：输出斐波那契数列中的前20个数。\n\n> 说明：斐波那契数列（Fibonacci sequence），通常也被称作黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda\n> Fibonacci）在《计算之书》中研究理想假设条件下兔子成长率问题而引入的数列，因此这个数列也常被戏称为“兔子数列”。斐波那契数列的特点是数列的前两个数都\n> 是1，从第三个数开始，每个数都是它前面两个数的和。按照这个规律，斐波那契数列的前10个数是：1, 1, 2, 3, 5, 8, 13, 21, 34,\n> 55。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。\n\n\n\n> 说明：上面循环中的a, b = b, a + b表示将变量b的值赋给a，把a + b的值赋给b。通过这个递推公式，我们可以依次获得斐波那契数列中的数。\n\n例子3：寻找水仙花数#\n\n要求：找出100到999范围内的所有水仙花数。\n\n> 提示：在数论中，水仙花数（narcissistic\n> number）也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个$\\small{N}$位非负整数，其各位数字的$\\small{N}$次方和刚好\n> 等于该数本身，例如：$\\small{153=1^3+5^3+3^3}$，所以153\n> 是一个水仙花数；$\\small{1634=1^4+6^4+3^4+4^4}$，所以1634也是一个水仙花数。对于三位数，解题的关键是将它拆分为个位、十位、百\n> 位，再判断是否满足水仙花数的要求，这一点利用Python中的//和%运算符其实很容易做到。\n\n\n\n上面利用//和%拆分一个数的小技巧在写代码的时候还是很常用的。我们要将一个不知道有多少位的正整数进行反转，例如将12389变成98321，也可以利用这两个运算来\n实现，代码如下所示。\n\n\n\n例子4：百钱百鸡问题#\n\n> 说明：百钱百鸡是我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现\n> 代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？\n\n\n\n上面使用的方法叫做穷举法，也称为暴力搜索法，这种方法通过一项一项的列举备选解决方案中所有可能的候选项，并检查每个候选项是否符合问题的描述，最终得到问题的解。上面\n的代码中，我们使用了嵌套的循环结构，假设公鸡有x只，显然x的取值范围是0到20，假设母鸡有y只，它的取值范围是0到33，假设小鸡有z只，它的取值范围是0到99且\n取值是3 的倍数。这样，我们设置好100只鸡的条件x + y + z == 100，设置好100块钱的条件5 * x + 3 * y + z // 3 ==\n100，当两个条件同时满足时，就是问题的正确答案，我们用print函数输出它。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至\n是不错的选择，只要问题的解存在就能够找到它。\n\n事实上，上面的代码还有更好的写法，既然我们已经假设公鸡有x只，母鸡有y只，那么小鸡的数量就应该是100 - x -\ny，这样减少一个条件，我们就可以把上面三层嵌套的for-in循环改写为两层嵌套的for-in循环。循环次数减少了，代码的执行效率就有了显著的提升，如下所示。\n\n\n\n> 说明：上面代码中的z % 3 == 0是为了确保小鸡的数量是3的倍数。\n\n例子5：CRAPS赌博游戏#\n\n> 说明：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一\n> 次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；玩家如果摇出其他点数则游戏继续，玩家重新摇骰子，如果玩家摇出了7点，庄\n> 家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。为了增加代码的趣味性，我们设定游戏开始时玩家有1000元的赌注，每局游戏开\n> 始之前，玩家先下注，如果玩家获胜就可以获得对应下注金额的奖励，如果庄家获胜，玩家就会输掉自己下注的金额。游戏结束的条件是玩家破产（输光所有的赌注）。\n\n\n\n\n总结#\n\n分支结构和循环结构都非常重要，是构造程序逻辑的基础，一定要通过大量的练习来达到融会贯通。我们可以用上面讲的花旗骰游戏作为一个标准，如果你能够很顺利的完成这段代码\n，那么分支结构和循环结构的知识你就已经很好的掌握了。",
    "routePath": "/tutorial/python/第07课：分支和循环结构的应用",
    "lang": "",
    "toc": [
      {
        "text": "第07课：分支结构和循环结构的应用",
        "id": "第07课分支结构和循环结构的应用",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "经典小案例",
        "id": "经典小案例",
        "depth": 3,
        "charIndex": 286
      },
      {
        "text": "例子1：100以内的素数",
        "id": "例子1100以内的素数",
        "depth": 4,
        "charIndex": 294
      },
      {
        "text": "例子2：斐波那契数列",
        "id": "例子2斐波那契数列",
        "depth": 4,
        "charIndex": 370
      },
      {
        "text": "例子3：寻找水仙花数",
        "id": "例子3寻找水仙花数",
        "depth": 4,
        "charIndex": 755
      },
      {
        "text": "例子4：百钱百鸡问题",
        "id": "例子4百钱百鸡问题",
        "depth": 4,
        "charIndex": 1173
      },
      {
        "text": "例子5：CRAPS赌博游戏",
        "id": "例子5craps赌博游戏",
        "depth": 4,
        "charIndex": 1850
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2190
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 12,
    "title": "",
    "content": "第08课：常用数据结构之列表-1#\n\n在开始本节课的内容之前，我们先给大家一个编程任务，将一颗色子掷6000次，统计每种点数出现的次数。这个任务对大家来说应该是非常简单的，我们可以用1到6均匀分布的\n随机数来模拟掷色子，然后用6个变量分别记录每个点数出现的次数，相信通过前面的学习，大家都能比较顺利的写出下面的代码。\n\n\n\n上面的代码非常有多么“丑陋”相信就不用我多说了。当然，更为可怕的是，如果我们要掷两颗或者掷更多的色子，然后统计每种点数出现的次数，那就需要定义更多的变量，写更多\n的分支结构，大家想想都会感到恶心。讲到这里，相信大家心中已经有一个疑问了：有没有办法用一个变量来保存多个数据，有没有办法用统一的代码对多个数据进行操作？答案是肯\n定的，在 Python 中我们可以通过容器类型的变量来保存和操作多个数据，我们首先为大家介绍列表（list）这种新的数据类型。\n\n\n创建列表#\n\n在 Python 中，列表是由一系元素按特定顺序构成的数据序列，这就意味着如果我们定义一个列表类型的变量，可以用它来保存多个数据。在 python\n中，可以使用[]字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。\n\n\n\n> 说明：列表中可以有重复元素，例如items1中的35；列表中可以有不同类型的元素，例如items3中有int类型、float类型、str类型和bool类型的\n> 元素，但是我们通常并不建议将不同类型的元素放在同一个列表中，主要是操作起来极为不方便。\n\n我们可以使用type函数来查看变量的类型，有兴趣的小伙伴可以自行查看上面的变量items1到底是什么类型。因为列表可以保存多个元素，它是一种容器型的数据类型，所\n以我们在给列表类型的变量起名字时，变量名通常用复数形式的单词。\n\n除此以外，还可以通过 Python\n内置的list函数将其他序列变成列表。准确的说，list并不是一个普通的函数，它是创建列表对象的构造器，后面的课程会为大家介绍对象和构造器这些概念。\n\n\n\n> 说明：range(1,\n> 10)会产生1到9的整数序列，给到list构造器中，会创建出由1到9的整数构成的列表。字符串是字符构成的序列，上面的list('hello')用字符串hel\n> lo的字符作为列表元素，创建了列表对象。\n\n\n列表的运算#\n\n我们可以使用+运算符实现两个列表的拼接，拼接运算会将两个列表中的元素连接起来放到一个列表中，代码如下所示。\n\n\n\n我们可以使用*运算符实现列表的重复运算，*运算符会将列表元素重复指定的次数，我们在上面的代码中增加两行，如下所示。\n\n\n\n我们可以使用in或not in运算符判断一个元素在不在列表中，我们在上面的代码代码中再增加两行，如下所示。\n\n\n\n由于列表中有多个元素，而且元素是按照特定顺序放在列表中的，所以当我们想操作列表中的某个元素时，可以使用[]运算符，通过在[]中指定元素的位置来访问该元素，这种运\n算称为索引运算。需要说明的是，[]的元素位置可以是0到N -\n1的整数，也可以是-1到-N的整数，分别称为正向索引和反向索引，其中N代表列表元素的个数。对于正向索引，[0]可以访问列表中的第一个元素，[N -\n1]可以访问最后一个元素；对于反向索引，[-1]可以访问列表中的最后一个元素，[-N]可以访问第一个元素，代码如下所示。\n\n\n\n在使用索引运算的时候要避免出现索引越界的情况，对于上面的items8，如果我们访问items8[5]或items8[-6]，就会引发IndexError错误，导\n致程序崩溃，对应的错误信息是：list index out of\nrange，翻译成中文就是“数组索引超出范围”。因为对于只有五个元素的列表items8，有效的正向索引是0到4，有效的反向索引是-1到-5。\n\n如果希望一次性访问列表中的多个元素，我们可以使用切片运算。切片运算是形如[start:end:stride]的运算符，其中start代表访问列表元素的起始位置，\nend代表访问列表元素的终止位置（终止位置的元素无法访问），而stride则代表了跨度，简单的说就是位置的增量，比如我们访问的第一个元素在start位置，那么第\n二个元素就在start + stride位置，当然start + stride要小于end。我们给上面的代码增加下面的语句，来使用切片运算符访问列表元素。\n\n\n\n> 提醒：大家可以看看上面代码中的最后一行，想一想当跨度为负数时，切片运算是如何访问元素的。\n\n如果start值等于0，那么在使用切片运算符时可以将其省略；如果end值等于N，N代表列表元素的个数，那么在使用切片运算符时可以将其省略；如果stride值等于\n1，那么在使用切片运算符时也可以将其省略。所以，下面的代码跟上面的代码作用完全相同。\n\n\n\n事实上，我们还可以通过切片操作修改列表中的元素，例如我们给上面的代码再加上一行，大家可以看看这里的输出。\n\n\n\n两个列表还可以做关系运算，我们可以比较两个列表是否相等，也可以给两个列表比大小，代码如下所示。\n\n\n\n> 说明：上面的nums1和nums2对应元素完全相同，所以==运算的结果是True。nums2和nums3的比较，由于nums2的第一个元素1小于nums3的\n> 第一个元素3，所以nums2 >= nums3比较的结果是False。两个列表的关系运算在实际工作并不那么常用，如果实在不理解就下面放放吧，不用纠结。\n\n\n元素的遍历#\n\n如果想逐个取出列表中的元素，可以使用for-in循环的，有以下两种做法。\n\n方法一：在循环结构中通过索引运算，遍历列表元素。\n\n\n\n输出：\n\n\n\n> 说明：上面的len函数可以获取列表元素的个数N，而range(N)则构成了从0到N-1的范围，刚好可以作为列表元素的索引。\n\n方法二：直接对列表做循环，循环变量就是列表元素的代表。\n\n\n\n输出：\n\n\n\n\n总结#\n\n讲到这里，我们可以用列表的知识来重构上面“掷色子统计每种点数出现次数”的代码。\n\n\n\n上面的代码中，我们用counters列表中的六个元素分别表示1到6点出现的次数，最开始的时候六个元素的值都是0。接下来，我们用1到6均匀分布的随机数模拟掷色子，\n如果摇出1点，counters[0]的值加1，如果摇出2点，counters[1]的值加1，以此类推。大家感受一下，由于使用了列表类型加上循环结构，我们对数据的\n处理是批量性的，这就使得修改后的代码比之前的代码要简单优雅得多。",
    "routePath": "/tutorial/python/第08课：常用数据结构之列表-1",
    "lang": "",
    "toc": [
      {
        "text": "第08课：常用数据结构之列表-1",
        "id": "第08课常用数据结构之列表-1",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "创建列表",
        "id": "创建列表",
        "depth": 3,
        "charIndex": 389
      },
      {
        "text": "列表的运算",
        "id": "列表的运算",
        "depth": 3,
        "charIndex": 974
      },
      {
        "text": "元素的遍历",
        "id": "元素的遍历",
        "depth": 3,
        "charIndex": 2279
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2464
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 13,
    "title": "",
    "content": "第09课：常用数据结构之列表-2#\n\n\n列表的方法#\n\n列表类型的变量拥有很多方法可以帮助我们操作一个列表，假设我们有名为foos的列表，列表有名为bar的方法，那么使用列表方法的语法是：foos.bar()，这是一\n种通过对象引用调用对象方法的语法。后面我们讲面向对象编程的时候，还会对这种语法进行详细的讲解，这种语法也称为给对象发消息。\n\n添加和删除元素#\n\n列表是一种可变容器，可变容器指的是我们可以向容器中添加元素、可以从容器移除元素，也可以修改现有容器中的元素。我们可以使用列表的append方法向列表中追加元素，\n使用insert方法向列表中插入元素。追加指的是将元素添加到列表的末尾，而插入则是在指定的位置添加新元素，大家可以看看下面的代码。\n\n\n\n我们可以用列表的remove方法从列表中删除指定元素，需要注意的是，如果要删除的元素并不在列表中，会引发ValueError错误导致程序崩溃，所以建议大家在删除\n元素时，先用之前讲过的成员运算做一个判断。我们还可以使用pop方法从列表中删除元素，pop方法默认删除列表中的最后一个元素，当然也可以给一个位置，删除指定位置的\n元素。在使用pop方法删除元素时，如果索引的值超出了范围，会引发IndexError异常，导致程序崩溃。除此之外，列表还有一个clear方法，可以清空列表中的元\n素，代码如下所示。\n\n\n\n> 说明：pop方法删除元素时会得到被删除的元素，上面的代码中，我们将pop方法删除的元素赋值给了名为temp的变量。当然如果你愿意，还可以把这个元素再次加入到\n> 列表中，正如上面的代码languages.append(temp)所做的那样。\n\n这里还有一个小问题，例如languages列表中有多个'Python'，那么我们用languages.remove('Python')是删除所有的'Python\n'，还是删除第一个'Python'，大家可以先猜一猜，然后再自己动手尝试一下。\n\n从列表中删除元素其实还有一种方式，就是使用 Python\n中的del关键字后面跟要删除的元素，这种做法跟使用pop方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优，因为del对应的底层字节\n码指令是DELETE_SUBSCR，而pop对应的底层字节码指令是CALL_METHOD和POP_TOP，如果不理解就不用管它了。\n\n\n\n元素位置和频次#\n\n列表的index方法可以查找某个元素在列表中的索引位置，如果找不到指定的元素，index方法会引发ValueError错误；列表的count方法可以统计一个元素\n在列表中出现的次数，代码如下所示。\n\n\n\n元素排序和反转#\n\n列表的sort操作可以实现列表元素的排序，而reverse操作可以实现元素的反转，代码如下所示。\n\n\n\n\n列表生成式#\n\n在 Python 中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。下面，我们通过例子来说明使用列表生成式创建列表到底有什么好处。\n\n场景一：创建一个取值范围在1到99且能被3或者5整除的数字构成的列表。\n\n\n\n使用列表生成式做同样的事情，代码如下所示。\n\n\n\n场景二：有一个整数列表nums1，创建一个新的列表nums2，nums2中的元素是nums1中对应元素的平方。\n\n\n\n使用列表生成式做同样的事情，代码如下所示。\n\n\n\n场景三： 有一个整数列表nums1，创建一个新的列表nums2，将nums1中大于50的元素放到nums2中。\n\n\n\n使用列表生成式做同样的事情，代码如下所示。\n\n\n\n使用列表生成式创建列表不仅代码简单优雅，而且性能上也优于使用for-in循环和append方法向空列表中追加元素的方式。为什么说生成式有更好的性能呢，那是因为\nPython\n解释器的字节码指令中有专门针对生成式的指令（LIST_APPEND指令）；而for循环是通过方法调用（LOAD_METHOD和CALL_METHOD指令）的方式\n为列表添加元素，方法调用本身就是一个相对比较耗时的操作。对这一点不理解也没有关系，记住“强烈建议用生成式语法来创建列表”这个结论就可以了。\n\n\n嵌套列表#\n\nPython\n语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表本身。如果列表中的元素也是列表，那么我们可以称之为嵌套的\n列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存5个学生3门课程的成绩，可以用如下所示的列表。\n\n\n\n对于上面的嵌套列表，每个元素相当于就是一个学生3门课程的成绩，例如[95, 83,\n92]，而这个列表中的83代表了这个学生某一门课的成绩，如果想访问这个值，可以使用两次索引运算scores[0][1]，其中scores[0]可以得到[95,\n83, 92]这个列表，再次使用索引运算[1]就可以获得该列表中的第二个元素。\n\n如果想通过键盘输入的方式来录入5个学生3门课程的成绩并保存在列表中，可以使用如下所示的代码。\n\n\n\n如果想通过产生随机数的方式来生成5个学生3门课程的成绩并保存在列表中，我们可以使用列表生成式，代码如下所示。\n\n\n\n> 说明：上面的代码[random.randrange(60, 101) for _ in range(3)]\n> 可以产生由3个随机整数构成的列表，我们把这段代码又放在了另一个列表生成式中作为列表的元素，这样的元素一共生成5个，最终得到了一个嵌套列表。\n\n\n列表应用举例#\n\n下面我们通过一个双色球随机选号的例子为大家讲解列表的应用。双色球是由中国福利彩票发行管理中心发售的乐透型彩票，每注投注号码由6个红色球和1个蓝色球组成。红色球号\n码从1到33中选择，蓝色球号码从1到16中选择。每注需要选择6个红色球号码和1个蓝色球号码，如下所示。\n\n> 提示：知乎上有一段对国内各种形式的彩票本质的论述相当精彩，这里分享给大家：“虚构一个不劳而获的人，去忽悠一群想不劳而获的人，最终养活一批真正不劳而获的人”。\n> 很多对概率没有概念的人，甚至认为彩票中与不中的概率都是50%；还有很多人认为如果中奖的概率是1%，那么买100次就一定可以中奖，这些都是非常荒唐的想法。所以\n> ，珍爱生命，远离（任何形式的）赌博！\n\n下面，我们通过 Python 程序来生成一组随机号码。\n\n\n\n> 说明：上面代码中print(f'\\033[0m...\\033[0m')是为了控制输出内容的颜色，红色球输出成红色，蓝色球输出成蓝色。其中省略号代表我们要输出\n> 的内容，\\033[0m是一个控制码，表示关闭所有属性，也就是说之前的控制码将会失效，你也可以将其简单的理解为一个定界符，m前面的0表示控制台的显示方式为默认\n> 值，0可以省略，1表示高亮，5表示闪烁，7表示反显等。在0和m的中间，我们可以写上代表颜色的数字，比如30代表黑色，31代表红色，32代表绿色，33代表黄色\n> ，34代表蓝色等。\n\n我们还可以利用random模块提供的sample和choice函数来简化上面的代码，前者可以实现无放回随机抽样，后者可以实现随机抽取一个元素，修改后的代码如下所\n示。\n\n\n\n如果要实现随机生成N注号码，我们只需要将上面的代码放到一个N次的循环中，如下所示。\n\n\n\n我们在 PyCharm 中运行上面的代码，输入5，运行效果如下图所示。\n\n\n总结#\n\nPython\n中的列表底层是一个可以动态扩容的数组，列表元素在计算机内存中是连续存储的，所以可以实现随机访问（通过一个有效的索引获取对应的元素且操作时间与列表元素个数无关）。\n我们可以暂时不去触碰这些底层的存储细节，也不需要大家理解列表每个方法的渐近时间复杂度（执行方法耗费的时间跟列表元素个数之间的关系），大家先学会用列表解决工作中的\n问题，我想这一点更为重要。",
    "routePath": "/tutorial/python/第09课：常用数据结构之列表-2",
    "lang": "",
    "toc": [
      {
        "text": "第09课：常用数据结构之列表-2",
        "id": "第09课常用数据结构之列表-2",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "列表的方法",
        "id": "列表的方法",
        "depth": 3,
        "charIndex": 19
      },
      {
        "text": "添加和删除元素",
        "id": "添加和删除元素",
        "depth": 4,
        "charIndex": 171
      },
      {
        "text": "元素位置和频次",
        "id": "元素位置和频次",
        "depth": 4,
        "charIndex": 1012
      },
      {
        "text": "元素排序和反转",
        "id": "元素排序和反转",
        "depth": 4,
        "charIndex": 1124
      },
      {
        "text": "列表生成式",
        "id": "列表生成式",
        "depth": 3,
        "charIndex": 1187
      },
      {
        "text": "嵌套列表",
        "id": "嵌套列表",
        "depth": 3,
        "charIndex": 1742
      },
      {
        "text": "列表应用举例",
        "id": "列表应用举例",
        "depth": 3,
        "charIndex": 2297
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3081
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 14,
    "title": "",
    "content": "第10课：常用数据结构之元组#\n\n前面的两节课，我们为大家讲解了 Python\n中的列表，它是一种容器型的数据类型，通过列表类型的变量，我们可以保存多个数据并通过循环实现对数据的批量操作。当然，Python\n中还有其他容器型的数据类型，接下来我们就为大家讲解另一种容器型的数据类型，它的名字叫元组（tuple）。\n\n\n元组的定义和运算#\n\n在 Python\n语言中，元组也是多个元素按照一定顺序构成的序列。元组和列表的不同之处在于，元组是不可变类型，这就意味着元组类型的变量一旦定义，其中的元素不能再添加或删除，而且元\n素的值也不能修改。如果试图修改元组中的元素，将引发TypeError错误，导致程序崩溃。定义元组通常使用形如(x, y,\nz)的字面量语法，元组类型支持的运算符跟列表是一样的，我们可以看看下面的代码。\n\n\n\n一个元组中如果有两个元素，我们就称之为二元组；一个元组中如果五个元素，我们就称之为五元组。需要提醒大家注意的是，()表示空元组，但是如果元组中只有一个元素，需要\n加上一个逗号，否则()就不是代表元组的字面量语法，而是改变运算优先级的圆括号，所以('hello', )和(100,\n)才是一元组，而('hello')和(100)只是字符串和整数。我们可以通过下面的代码来加以验证。\n\n\n\n\n打包和解包操作#\n\n当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量，如下面的代码所\n示。\n\n\n\n在解包时，如果解包出来的元素个数和变量个数不对应，会引发ValueError异常，错误信息为：too many values to\nunpack（解包的值太多）或not enough values to unpack（解包的值不足）。\n\n\n\n有一种解决变量个数少于元素的个数方法，就是使用星号表达式。通过星号表达式，我们可以让一个变量接收多个值，代码如下所示。需要注意两点：首先，用星号表达式修饰的变量\n会变成一个列表，列表中有0个或多个元素；其次，在解包语法中，星号表达式只能出现一次。\n\n\n\n需要说明一点，解包语法对所有的序列都成立，这就意味着我们之前讲的列表、range函数构造的范围序列甚至字符串都可以使用解包语法。大家可以尝试运行下面的代码，看看\n会出现怎样的结果。\n\n\n\n\n交换变量的值#\n\n交换变量的值是写代码时经常用到的一个操作，但是在很多编程语言中，交换两个变量的值都需要借助一个中间变量才能做到，如果不用中间变量就需要使用比较晦涩的位运算来实现\n。在 Python 中，交换两个变量a和b的值只需要使用如下所示的代码。\n\n\n\n同理，如果要将三个变量a、b、c的值互换，即b的值赋给a，c的值赋给b，a的值赋给c，也可以如法炮制。\n\n\n\n需要说明的是，上面的操作并没有用到打包和解包语法，Python\n的字节码指令中有ROT_TWO和ROT_THREE这样的指令可以直接实现这个操作，效率是非常高的。但是如果有多于三个变量的值要依次互换，这个时候是没有直接可用的\n字节码指令的，需要通过打包解包的方式来完成变量之间值的交换。\n\n\n元组和列表的比较#\n\n这里还有一个非常值得探讨的问题，Python\n中已经有了列表类型，为什么还需要元组这样的类型呢？这个问题对于初学者来说似乎有点困难，不过没有关系，我们先抛出观点，大家可以一边学习一边慢慢体会。\n\n 1. 元组是不可变类型，不可变类型更适合多线程环境，因为它降低了并发访问变量的同步化开销。关于这一点，我们会在后面讲解并发编程的时候跟大家一起探讨。\n\n 2. 元组是不可变类型，通常不可变类型在创建时间上优于对应的可变类型。我们可以使用timeit模块的timeit函数来看看创建保存相同元素的元组和列表各自花费\n    的时间，timeit函数的number参数表示代码执行的次数。下面的代码中，我们分别创建了保存1到9的整数的列表和元组，每个操作执行10000000次，\n    统计运行时间。\n    \n    \n    \n    输出：\n    \n    \n    \n    > 说明：上面代码的执行结果因软硬件系统而异，在我目前使用的电脑上，执行10000000次创建列表的操作时间是0.635秒，而执行10000000次创建\n    > 元组的操作时间是0.078秒，显然创建元组更快且二者时间上有数量级的差别。大家可以在自己的电脑上执行这段代码，把你的执行结果放到评论区，看看谁的电脑\n    > 更厉害。\n\n当然，Python 中的元组和列表类型是可以相互转换的，我们可以通过下面的代码来完成该操作。\n\n\n\n\n总结#\n\n列表和元组都是容器型的数据类型，即一个变量可以保存多个数据，而且它们都是按一定顺序组织元素的有序容器。列表是可变数据类型，元组是不可变数据类型，所以列表可以添加\n元素、删除元素、清空元素、排序反转，但这些操作对元组来说是不成立的。列表和元组都可以支持拼接运算、成员运算、索引运算、切片运算等操作，后面我们要讲到的字符串类型\n也支持这些运算，因为字符串就是字符按一定顺序构成的序列，在这一点上三者并没有什么区别。我们推荐大家使用列表的生成式语法来创建列表，它不仅好用而且效率很高，是\nPython 语言中非常有特色的语法。",
    "routePath": "/tutorial/python/第10课：常用数据结构之元组",
    "lang": "",
    "toc": [
      {
        "text": "第10课：常用数据结构之元组",
        "id": "第10课常用数据结构之元组",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "元组的定义和运算",
        "id": "元组的定义和运算",
        "depth": 3,
        "charIndex": 158
      },
      {
        "text": "打包和解包操作",
        "id": "打包和解包操作",
        "depth": 3,
        "charIndex": 557
      },
      {
        "text": "交换变量的值",
        "id": "交换变量的值",
        "depth": 3,
        "charIndex": 997
      },
      {
        "text": "元组和列表的比较",
        "id": "元组和列表的比较",
        "depth": 3,
        "charIndex": 1328
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 1951
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 15,
    "title": "",
    "content": "第11课：常用数据结构之字符串#\n\n第二次世界大战促使了现代电子计算机的诞生，世界上的第一台通用电子计算机名叫\nENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，占地167平米，重量约27吨，每秒钟大约能够完成约5000次浮点运算，如下图所示。ENIAC\n诞生之后被应用于导弹弹道的计算，而数值计算也是现代电子计算机最为重要的一项功能。\n\n随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的组成部分，但是今天的计算机还要处理大量的以文本形式存在的信息。如果我们希望通过 Python\n程序来操作本这些文本信息，就必须要先了解字符串这种数据类型以及与它相关的运算和方法。\n\n\n字符串的定义#\n\n所谓字符串，就是由零个或多个字符组成的有限序列，一般记为： $$ s = a_1a_2 \\cdots a_n ,,,,, (0 \\le n \\le\n\\infty) $$ 在 Python\n程序中，我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。字符串中的字符可以是特殊符号、英文字母、中文字符、日文的平假名或片假名、希腊字母、\nEmoji 字符（如：💩、🐷、🀄️）等。\n\n\n\n转义字符#\n\n我们可以在字符串中使用\\（反斜杠）来表示转义，也就是说\\后面的字符不再是它原来的意义，例如：\\n不是代表字符\\和字符n，而是表示换行；\\t也不是代表字符\\和字符\nt，而是表示制表符。所以如果字符串本身又包含了'、\"、\\这些特殊的字符，必须要通过\\进行转义处理。例如要输出一个带单引号或反斜杠的字符串，需要用如下所示的方法。\n\n\n\n原始字符串#\n\nPython\n中有一种以r或R开头的字符串，这种字符串被称为原始字符串，意思是字符串中的每个字符都是它本来的含义，没有所谓的转义字符。例如，在字符串'hello\\n'中，\\n\n表示换行；而在r'hello\\n'中，\\n不再表示换行，就是字符\\和字符n。大家可以运行下面的代码，看看会输出什么。\n\n\n\n> 说明：上面的变量s1中，\\t、\\r和\\n都是转义字符。\\t是制表符（table），\\n是换行符（new line），\\r是回车符（carriage\n> return）相当于让输出回到了行首。对比一下两个print函数的输出，看看到底有什么区别！\n\n字符的特殊表示#\n\nPython\n中还允许在\\后面还可以跟一个八进制或者十六进制数来表示字符，例如\\141和\\x61都代表小写字母a，前者是八进制的表示法，后者是十六进制的表示法。另外一种表示字\n符的方式是在\\u后面跟 Unicode 字符编码，例如\\u9a86\\u660a代表的是中文“骆昊”。运行下面的代码，看看输出了什么。\n\n\n\n\n字符串的运算#\n\nPython\n语言为字符串类型提供了非常丰富的运算符，有很多运算符跟列表类型的运算符作用类似。例如，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的\n内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串，我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符。\n\n拼接和重复#\n\n下面的例子演示了使用+和*运算符来实现字符串的拼接和重复操作。\n\n\n\n用*实现字符串的重复是非常有意思的一个运算符，在很多编程语言中，要表示一个有10个a的字符串，你只能写成'aaaaaaaaaa'，但是在 Python\n中，你可以写成'a' * 10。你可能觉得'aaaaaaaaaa'这种写法也没有什么不方便的，但是请想一想，如果字符a要重复100次或者1000次又会如何呢？\n\n比较运算#\n\n对于两个字符串类型的变量，可以直接使用比较运算符来判断两个字符串的相等性或比较大小。需要说明的是，因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大\n小比较比的是每个字符对应的编码的大小。例如A的编码是65， 而a的编码是97，所以'A' < 'a'的结果相当于就是65 <\n97的结果，这里很显然是True；而'boy' < 'bad'，因为第一个字符都是'b'比不出大小，所以实际比较的是第二个字符的大小，显然'o' <\n'a'的结果是False，所以'boy' <\n'bad'的结果是False。如果不清楚两个字符对应的编码到底是多少，可以使用ord函数来获得，之前我们有提到过这个函数。例如ord('A')的值是65，而or\nd('昊')的值是26122。下面的代码展示了字符串的比较运算，请大家仔细看看。\n\n\n\n成员运算#\n\nPython 中可以用in和not in判断一个字符串中是否包含另外一个字符或字符串，跟列表类型一样，in和not\nin称为成员运算符，会产生布尔值True或False，代码如下所示。\n\n\n\n获取字符串长度#\n\n获取字符串长度跟获取列表元素个数一样，使用内置函数len，代码如下所示。\n\n\n\n索引和切片#\n\n字符串的索引和切片操作跟列表几乎区别，因为字符串也是一种有序序列，可以通过正向或反向的整数索引访问其中的元素。但是有一点需要注意，因为字符串是不可变类型，所以不\n能通过索引运算修改字符串中的字符。\n\n\n\n需要再次提醒大家注意的是，在进行索引运算时，如果索引越界，会引发IndexError异常，错误提示信息为：string index out of\nrange（字符串索引超出范围）。\n\n\n字符的遍历#\n\n如果希望遍历字符串中的每个字符，可以使用for-in循环，有如下所示的两种方式。\n\n方式一：\n\n\n\n方式二：\n\n\n\n\n字符串的方法#\n\n在 Python\n中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，假设我们有名为foo的字符串，字符串有名为bar的方法，那么使用字符串方法的语法是：foo.bar(\n)，这是一种通过对象引用调用对象方法的语法，跟前面使用列表方法的语法是一样的。\n\n大小写相关操作#\n\n下面的代码演示了和字符串大小写变换相关的方法。\n\n\n\n> 说明：由于字符串是不可变类型，使用字符串的方法对字符串进行操作会产生新的字符串，但是原来变量的值并没有发生变化。所以上面的代码中，当我们最后检查s1和s2两\n> 个变量的值时，s1和s2 的值并没有发生变化。\n\n查找操作#\n\n如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的find或index方法。在使用find和index方法时还可以通过方法的参数来指定查找的\n范围，也就是查找不必从索引为0的位置开始。\n\n\n\n> 说明：find方法找不到指定的字符串会返回-1，index方法找不到指定的字符串会引发ValueError错误。\n\nfind和index方法还有逆向查找（从后向前查找）的版本，分别是rfind和rindex，代码如下所示。\n\n\n\n性质判断#\n\n可以通过字符串的startswith、endswith来判断字符串是否以某个字符串开头和结尾；还可以用is开头的方法判断字符串的特征，这些方法都返回布尔值，代码\n如下所示。\n\n\n\n> 说明：上面的isdigit用来判断字符串是不是完全由数字构成的，isalpha用来判断字符串是不是完全由字母构成的，这里的字母指的是 Unicode\n> 字符但不包含 Emoji 字符，isalnum用来判断字符串是不是由字母和数字构成的。\n\n格式化字符串#\n\n在 Python\n中，字符串类型可以通过center、ljust、rjust方法做居中、左对齐和右对齐的处理。如果要在字符串的左侧补零，也可以使用zfill方法。\n\n\n\n我们之前讲过，在用print函数输出字符串时，可以用下面的方式对字符串进行格式化。\n\n\n\n当然，我们也可以用字符串的format方法来完成字符串的格式，代码如下所示。\n\n\n\n从 Python 3.6\n开始，格式化字符串还有更为简洁的书写方式，就是在字符串前加上f来格式化字符串，在这种以f打头的字符串中，{变量名}是一个占位符，会被变量对应的值将其替换掉，代码\n如下所示。\n\n\n\n如果需要进一步控制格式化语法中变量值的形式，可以参照下面的表格来进行字符串格式化操作。\n\n变量值         占位符        格式化结果           说明\n3.1415926   {:.2f}     '3.14'          保留小数点后两位\n3.1415926   {:+.2f}    '+3.14'         带符号保留小数点后两位\n-1          {:+.2f}    '-1.00'         带符号保留小数点后两位\n3.1415926   {:.0f}     '3'             不带小数\n123         {:0>10d}   '0000000123'    左边补0，补够10位\n123         {:x<10d}   '123xxxxxxx'    右边补x ，补够10位\n123         {:>10d}    ' 123'          左边补空格，补够10位\n123         {:<10d}    '123 '          右边补空格，补够10位\n123456789   {:,}       '123,456,789'   逗号分隔格式\n0.123       {:.2%}     '12.30%'        百分比格式\n123456789   {:.2e}     '1.23e+08'      科学计数法格式\n\n修剪操作#\n\n字符串的strip方法可以帮我们获得将原字符串修剪掉左右两端指定字符之后的字符串，默认是修剪空格字符。这个方法非常有实用价值，可以用来将用户输入时不小心键入的头\n尾空格等去掉，strip方法还有lstrip和rstrip两个版本，相信从名字大家已经猜出来这两个方法是做什么用的。\n\n\n\n替换操作#\n\n如果希望用新的内容替换字符串中指定的内容，可以使用replace方法，代码如下所示。replace方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可\n以通过第三个参数指定替换的次数。\n\n\n\n拆分与合并#\n\n可以使用字符串的split方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的join方法将列表中的多个字符串连接成一个字符串，代码如下所示。\n\n\n\n需要说明的是，split方法默认使用空格进行拆分，我们也可以指定其他的字符来拆分字符串，而且还可以指定最大拆分次数来控制拆分的效果，代码如下所示。\n\n\n\n编码和解码#\n\nPython\n中除了字符串str类型外，还有一种表示二进制数据的字节串类型（bytes）。所谓字节串，就是由零个或多个字节组成的有限序列。通过字符串的encode方法，我们可\n以按照某种编码方式将字符串编码为字节串，我们也可以使用字节串的decode方法，将字节串解码为字符串，代码如下所示。\n\n\n\n注意，如果编码和解码的方式不一致，会导致乱码问题（无法再现原始的内容）或引发UnicodeDecodeError错误，导致程序崩溃。\n\n其他方法#\n\n对于字符串类型来说，还有一个常用的操作是对字符串进行匹配检查，即检查字符串是否满足某种特定的模式。例如，一个网站对用户注册信息中用户名和邮箱的检查，就属于模式匹\n配检查。实现模式匹配检查的工具叫做正则表达式，Python 语言通过标准库中的re模块提供了对正则表达式的支持，我们会在后续的课程中为大家讲解这个知识点。\n\n\n总结#\n\n知道如何表示和操作字符串对程序员来说是非常重要的，因为我们经常需要处理文本信息，Python\n中操作字符串可以用拼接、索引、切片等运算符，也可以使用字符串类型提供的非常丰富的方法。",
    "routePath": "/tutorial/python/第11课：常用数据结构之字符串",
    "lang": "",
    "toc": [
      {
        "text": "第11课：常用数据结构之字符串",
        "id": "第11课常用数据结构之字符串",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "字符串的定义",
        "id": "字符串的定义",
        "depth": 3,
        "charIndex": 297
      },
      {
        "text": "转义字符",
        "id": "转义字符",
        "depth": 4,
        "charIndex": 508
      },
      {
        "text": "原始字符串",
        "id": "原始字符串",
        "depth": 4,
        "charIndex": 680
      },
      {
        "text": "字符的特殊表示",
        "id": "字符的特殊表示",
        "depth": 4,
        "charIndex": 964
      },
      {
        "text": "字符串的运算",
        "id": "字符串的运算",
        "depth": 3,
        "charIndex": 1133
      },
      {
        "text": "拼接和重复",
        "id": "拼接和重复",
        "depth": 4,
        "charIndex": 1299
      },
      {
        "text": "比较运算",
        "id": "比较运算",
        "depth": 4,
        "charIndex": 1499
      },
      {
        "text": "成员运算",
        "id": "成员运算",
        "depth": 4,
        "charIndex": 1873
      },
      {
        "text": "获取字符串长度",
        "id": "获取字符串长度",
        "depth": 4,
        "charIndex": 1976
      },
      {
        "text": "索引和切片",
        "id": "索引和切片",
        "depth": 4,
        "charIndex": 2026
      },
      {
        "text": "字符的遍历",
        "id": "字符的遍历",
        "depth": 3,
        "charIndex": 2229
      },
      {
        "text": "字符串的方法",
        "id": "字符串的方法",
        "depth": 3,
        "charIndex": 2296
      },
      {
        "text": "大小写相关操作",
        "id": "大小写相关操作",
        "depth": 4,
        "charIndex": 2436
      },
      {
        "text": "查找操作",
        "id": "查找操作",
        "depth": 4,
        "charIndex": 2581
      },
      {
        "text": "性质判断",
        "id": "性质判断",
        "depth": 4,
        "charIndex": 2811
      },
      {
        "text": "格式化字符串",
        "id": "格式化字符串",
        "depth": 4,
        "charIndex": 3032
      },
      {
        "text": "修剪操作",
        "id": "修剪操作",
        "depth": 4,
        "charIndex": 3939
      },
      {
        "text": "替换操作",
        "id": "替换操作",
        "depth": 4,
        "charIndex": 4089
      },
      {
        "text": "拆分与合并",
        "id": "拆分与合并",
        "depth": 4,
        "charIndex": 4197
      },
      {
        "text": "编码和解码",
        "id": "编码和解码",
        "depth": 4,
        "charIndex": 4366
      },
      {
        "text": "其他方法",
        "id": "其他方法",
        "depth": 4,
        "charIndex": 4592
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 4760
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 16,
    "title": "",
    "content": "第12课：常用数据结构之集合#\n\n在学习了列表和元组之后，我们再来学习一种容器型的数据类型，它的名字叫集合（set）。说到集合这个词大家一定不会陌生，在数学课本上就有这个概念。如果我们把一定范围\n的、确定的、可以区别的事物当作一个整体来看待，那么这个整体就是集合，集合中的各个事物称为集合的元素。通常，集合需要满足以下特性：\n\n 1. 无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。\n 2. 互异性：一个集合中，任何两个元素都是不相同的，即元素在集合中只能出现一次。\n 3. 确定性：给定一个集合和一个任意元素，该元素要么属这个集合，要么不属于这个集合，二者必居其一，不允许有模棱两可的情况出现。\n\nPython\n程序中的集合跟数学上的集合没有什么本质区别，需要强调的是上面所说的无序性和互异性。无序性说明集合中的元素并不像列中的元素那样存在某种次序，可以通过索引运算就能访\n问任意元素，集合并不支持索引运算。另外，集合的互异性决定了集合中不能有重复元素，这一点也是集合区别于列表的地方，我们无法将重复的元素添加到一个集合中。集合类型必\n然是支持in和not\nin成员运算的，这样就可以确定一个元素是否属于集合，也就是上面所说的集合的确定性。集合的成员运算在性能上要优于列表的成员运算，这是集合的底层存储特性决定的，此处\n我们暂时不做讨论，大家记住这个结论即可。\n\n> 说明：集合底层使用了哈希存储（散列存储），对哈希存储感兴趣的读者可以看看维基百科上“散列表”这个词条。\n\n\n创建集合#\n\n在 Python\n中，创建集合可以使用{}字面量语法，{}中需要至少有一个元素，因为没有元素的{}并不是空集合而是一个空字典，字典类型我们会在下一节课中为大家介绍。当然，也可以使\n用 Python\n内置函数set来创建一个集合，准确的说set并不是一个函数，而是创建集合对象的构造器，这个知识点会在后面讲解面向对象编程的地方为大家介绍。我们可以使用set函数\n创建一个空集合，也可以用它将其他序列转换成集合，例如：set('hello')会得到一个包含了4个字符的集合（重复的字符l只会在集合中出现一次）。除了这两种方式\n，还可以使用生成式语法来创建集合，就像我们之前用生成式语法创建列表那样。\n\n\n\n需要提醒大家，集合中的元素必须是hashable类型，使用哈希存储的容器都会对元素提出这一要求。所谓hashable类型指的是能够计算出哈希码的数据类型，通常不\n可变类型都是hashable类型，如整数（int）、浮点小数（float）、布尔值（bool）、字符串（str）、元组（tuple）等。可变类型都不是hasha\nble类型，因为可变类型无法计算出确定的哈希码，所以它们不能放到集合中。例如：我们不能将列表作为集合中的元素；同理，由于集合本身也是可变类型，所以集合也不能作为\n集合中的元素。我们可以创建出嵌套的列表，但是我们不能创建出嵌套的集合，这一点在使用集合的时候一定要引起注意。\n\n\n集合的遍历#\n\n我们可以通过len函数来获得集合中有多少个元素，但是我们不能通过索引运算来遍历集合中的元素，因为集合元素并没有特定的顺序。当然，要实现对集合元素的遍历，我们仍然\n可以使用for-in循环，代码如下所示。\n\n\n\n> 提示：大家看看上面代码的运行结果，通过单词输出的顺序体会一下集合的无序性。\n\n\n集合的运算#\n\nPython 为集合类型提供了非常丰富的运算符，主要包括：成员运算、交集运算、并集运算、差集运算、比较运算（相等性、子集、超集）等。\n\n成员运算#\n\n可以通过成员运算in和not in 检查元素是否在集合中，代码如下所示。\n\n\n\n二元运算#\n\n集合的二元运算主要指集合的交集、并集、差集、对称差等运算，这些运算可以通过运算符来实现，也可以通过集合类型的方法来实现，代码如下所示。\n\n\n\n通过上面的代码可以看出，对两个集合求交集，&运算符和intersection方法的作用是完全相同的，使用运算符的方式显然更直观且代码也更简短。需要说明的是，集合\n的二元运算还可以跟赋值运算一起构成复合赋值运算，例如：set1 |= set2相当于set1 = set1 |\nset2，跟|=作用相同的方法是update；set1 &= set2相当于set1 = set1 &\nset2，跟&=作用相同的方法是intersection_update，代码如下所示。\n\n\n\n比较运算#\n\n两个集合可以用==和!=进行相等性判断，如果两个集合中的元素完全相同，那么==比较的结果就是True，否则就是False。如果集合A的任意一个元素都是集合B的元\n素，那么集合A称为集合B的子集，即对于$\\small{\\forall{a} \\in {A}}$，均有$\\small{{a} \\in\n{B}}$，则$\\small{{A} \\subseteq\n{B}}$，A是B的子集，反过来也可以称B是A的超集。如果A是B的子集且A不等于B，那么A就是B的真子集。Python\n为集合类型提供了判断子集和超集的运算符，其实就是我们非常熟悉的<、<=、>、>=这些运算符。当然，我们也可以通过集合类型的方法issubset和issupers\net来判断集合之间的关系，代码如下所示。\n\n\n\n> 说明：上面的代码中，set1 < set2判断set1是不是set2的真子集，set1 <= set2判断set1是不是set2的子集，set2 >\n> set1判断set2是不是set1的超集。当然，我们也可以通过set1.issubset(set2)判断set1是不是set2的子集；通过set2.issu\n> perset(set1)判断set2是不是set1的超集。\n\n\n集合的方法#\n\n刚才我们说过，Python 中的集合是可变类型，我们可以通过集合类型的方法向集合添加元素或从集合中删除元素。\n\n\n\n> 说明：删除集合元素的remove方法在元素不存在时会引发KeyError错误，所以上面的代码中我们先通过成员运算判断元素是否在集合中。集合类型还有一个pop\n> 方法可以从集合中随机删除一个元素，该方法在删除元素的同时会获得被删除的元素，而remove和discard方法仅仅是删除元素，不会获得被删除的元素。\n\n集合类型还有一个名为isdisjoint的方法可以判断两个集合有没有相同的元素，如果没有相同元素，该方法返回True，否则该方法返回False，代码如下所示。\n\n\n\n\n不可变集合#\n\nPython\n中还有一种不可变类型的集合，名字叫frozenset。set跟frozenset的区别就如同list跟tuple的区别，frozenset由于是不可变类型，能够\n计算出哈希码，因此它可以作为set中的元素。除了不能添加和删除元素，frozenset在其他方面跟set是一样的，下面的代码简单的展示了frozenset的用法\n。\n\n\n\n\n总结#\n\nPython\n中的集合类型是一种无序容器，不允许有重复运算，由于底层使用了哈希存储，集合中的元素必须是hashable类型。集合与列表最大的区别在于集合中的元素没有顺序、所以\n不能够通过索引运算访问元素、但是集合可以执行交集、并集、差集等二元运算，也可以通过关系运算符检查两个集合是否存在超集、子集等关系。",
    "routePath": "/tutorial/python/第12课：常用数据结构之集合",
    "lang": "",
    "toc": [
      {
        "text": "第12课：常用数据结构之集合",
        "id": "第12课常用数据结构之集合",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "创建集合",
        "id": "创建集合",
        "depth": 3,
        "charIndex": 647
      },
      {
        "text": "集合的遍历",
        "id": "集合的遍历",
        "depth": 3,
        "charIndex": 1255
      },
      {
        "text": "集合的运算",
        "id": "集合的运算",
        "depth": 3,
        "charIndex": 1410
      },
      {
        "text": "成员运算",
        "id": "成员运算",
        "depth": 4,
        "charIndex": 1486
      },
      {
        "text": "二元运算",
        "id": "二元运算",
        "depth": 4,
        "charIndex": 1533
      },
      {
        "text": "比较运算",
        "id": "比较运算",
        "depth": 4,
        "charIndex": 1847
      },
      {
        "text": "集合的方法",
        "id": "集合的方法",
        "depth": 3,
        "charIndex": 2387
      },
      {
        "text": "不可变集合",
        "id": "不可变集合",
        "depth": 3,
        "charIndex": 2696
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2879
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 17,
    "title": "",
    "content": "第13课：常用数据结构之字典#\n\n迄今为止，我们已经为大家介绍了Python中的三种容器型数据类型（列表、元组、集合），但是这些数据类型仍然不足以帮助我们解决所有的问题。例如，我们需要一个变量来\n保存一个人的多项信息，包括：姓名、年龄、身高、体重、家庭住址、本人手机号、紧急联系人手机号，此时你会发现，我们之前学过的列表、元组和集合类型都不够好使。\n\n\n\n集合肯定是最不合适的，因为集合中不能有重复元素，如果一个人的年龄和体重刚好相同，那么集合中就会少一项信息；同理，如果这个人的手机号和紧急联系人手机号是相同的，那\n么集合中又会少一项信息。另一方面，虽然列表和元组可以把一个人的所有信息都保存下来，但是当你想要获取这个人的手机号或家庭住址时，你得先知道他的手机号是列表或元组中\n的第几个元素。总之，在遇到上述的场景时，列表、元组、集合都不是最合适的选择，此时我们需要字典（dictionary）类型，这种数据类型最适合把相关联的信息组装到\n一起，可以帮助我们解决 Python 程序中为真实事物建模的问题。\n\n说到字典这个词，大家一定不陌生，读小学的时候，每个人手头基本上都有一本《新华字典》，如下图所示。\n\nPython\n程序中的字典跟现实生活中的字典很像，它以键值对（键和值的组合）的方式把数据组织到一起，我们可以通过键找到与之对应的值并进行操作。就像《新华字典》中，每个字（键）\n都有与它对应的解释（值）一样，每个字和它的解释合在一起就是字典中的一个条目，而字典中通常包含了很多个这样的条目。\n\n\n创建和使用字典#\n\nPython\n中创建字典可以使用{}字面量语法，这一点跟上一节课讲的集合是一样的。但是字典的{}中的元素是以键值对的形式存在的，每个元素由:分隔的两个值构成，:前面是键，:后\n面是值，代码如下所示。\n\n\n\n通过上面的代码，相信大家已经看出来了，用字典来保存一个人的信息远远优于使用列表或元组，因为我们可以用:前面的键来表示条目的含义，而:后面就是这个条目所对应的值。\n\n当然，如果愿意，我们也可以使用内置函数dict或者是字典的生成式语法来创建字典，代码如下所示。\n\n\n\n想知道字典中一共有多少组键值对，仍然是使用len函数；如果想对字典进行遍历，可以用for循环，但是需要注意，for循环只是对字典的键进行了遍历，不过没关系，在学\n习了字典的索引运算后，我们可以通过字典的键获取到和这个键对应的值。\n\n\n\n\n字典的运算#\n\n对于字典类型来说，成员运算和索引运算肯定是很重要的，前者可以判定指定的键在不在字典中，后者可以通过键获取对应的值或者向字典中添加新的键值对。值得注意的是，字典的\n索引不同于列表的索引，列表中的元素因为有属于自己有序号，所以列表的索引是一个整数；字典中因为保存的是键值对，所以字典需要用键去索引对应的值。需要特别提醒大家注意\n的是，字典中的键必须是不可变类型，例如整数（int）、浮点数（float）、字符串（str）、元组（tuple）等类型，这一点跟集合类型对元素的要求是一样的；很\n显然，之前我们讲的列表（list）和集合（set）不能作为字典中的键，字典类型本身也不能再作为字典中的键，因为字典也是可变类型，但是字典可以作为字典中的值。大家\n可以先看看下面的代码，了解一下字典的成员运算和索引运算。\n\n\n\n需要注意，在通过索引运算获取字典中的值时，如指定的键没有在字典中，将会引发KeyError异常。\n\n\n字典的方法#\n\n字典类型的方法基本上都跟字典的键值对操作相关，其中get方法可以通过键来获取对应的值。跟索引运算不同的是，get方法在字典中没有指定的键时不会产生异常，而是返回\nNone或指定的默认值，代码如下所示。\n\n\n\n如果需要获取字典中所有的键，可以使用keys方法；如果需要获取字典中所有的值，可以使用values方法。字典还有一个名为items的方法，它会将键和值组装成二元\n组，通过该方法来遍历字典中的元素也是非常方便的。\n\n\n\n字典的update方法会用一个字典更新另一个字典中的键值对。例如，有两个字典x和y，当执行x.update(y)操作时，x跟y相同的键对应的值会y中的值被更新，\n而y中有但x中没有的键值对会直接添加到x中，代码如下所示。\n\n\n\n可以通过pop或popitem方法从字典中删除元素，前者会返回键对应的值，但是如果字典中不存在指定的键，会引发KeyError错误；后者在删除元素时，会返回键和\n值组成的二元组。字典的clear方法会清空字典中所有的键值对，代码如下所示。\n\n\n\n跟列表一样，从字典中删除元素也可以使用del关键字，在删除元素的时候如果指定的键索引不到对应的值，一样会引发KeyError错误，具体的做法如下所示。\n\n\n\n\n字典的应用#\n\n我们通过几个简单的例子来看看如何使用字典类型解决一些实际的问题。\n\n例子1：输入一段话，统计每个英文字母出现的次数，按出现次数从高到低输出。\n\n\n\n输入：\n\n\n\n输出：\n\n\n\n例子2：在一个字典中保存了股票的代码和价格，找出股价大于100元的股票并创建一个新的字典。\n\n> 说明：可以用字典的生成式语法来创建这个新字典。\n\n\n\n输出：\n\n\n\n\n总结#\n\nPython\n程序中的字典跟现实生活中字典非常像，允许我们以键值对的形式保存数据，再通过键索引对应的值。这是一种非常有利于数据检索的数据类型。再次提醒大家注意，字典中的键必须\n是不可变类型，字典中的值可以是任意类型。",
    "routePath": "/tutorial/python/第13课：常用数据结构之字典",
    "lang": "",
    "toc": [
      {
        "text": "第13课：常用数据结构之字典",
        "id": "第13课常用数据结构之字典",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "创建和使用字典",
        "id": "创建和使用字典",
        "depth": 3,
        "charIndex": 652
      },
      {
        "text": "字典的运算",
        "id": "字典的运算",
        "depth": 3,
        "charIndex": 1017
      },
      {
        "text": "字典的方法",
        "id": "字典的方法",
        "depth": 3,
        "charIndex": 1432
      },
      {
        "text": "字典的应用",
        "id": "字典的应用",
        "depth": 3,
        "charIndex": 1970
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2150
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 18,
    "title": "",
    "content": "第14课：函数和模块#\n\n在讲解本节课的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。 $$ x_1 + x_2 + x_3 + x_4 = 8 $$\n\n你可能已经想到了，这个问题其实等同于将8个苹果分成四组且每组至少一个苹果有多少种方案，也等价于在分隔8个苹果的7个间隙之间放入三个隔断将苹果分成四组有多少种方案\n，所以答案是$ C_7^3=35 $，其中，$C_{7}^{3}$代表7选3的组合数，其计算公式如下所示。 $$ C_m^n = \\frac {m!}\n{n!(m-n)!} $$\n\n根据之前学习的知识，我们可以用循环做累乘的方式分别计算出$m!$、$n!$和$(m-n)!$，然后再通过除法运算得到组合数$C_m^n$，代码如下所示。\n\n\n\n输入：\n\n\n\n输出：\n\n\n\n不知大家是否注意到，上面的代码中我们做了三次求阶乘的操作，虽然$m$、$n$、$m -\nn$的值各不相同，但是三段代码并没有实质性的区别，属于重复代码。世界级的编程大师Martin\nFowler曾经说过：“代码有很多种坏味道，重复是最坏的一种！”。要写出高质量的代码，首先就要解决重复代码的问题。对于上面的代码来说，我们可以将求阶乘的功能封装\n到一个称为“函数”的代码块中，在需要计算阶乘的地方，我们只需“调用函数”即可实现对求阶乘功能的复用。\n\n\n定义函数#\n\n数学上的函数通常形如$y = f(x)$或者$z = g(x, y)$这样的形式，在$y =\nf(x)$中，$f$是函数的名字，$x$是函数的自变量，$y$是函数的因变量；而在$z = g(x,\ny)$中，$g$是函数名，$x$和$y$是函数的自变量，$z$是函数的因变量。Python\n中的函数跟这个结构是一致的，每个函数都有自己的名字、自变量和因变量。我们通常把 Python 函数的自变量称为函数的参数，而因变量称为函数的返回值。\n\nPython\n中可以使用def关键字来定义函数，和变量一样每个函数也应该有一个漂亮的名字，命名规则跟变量的命名规则是一样的（大家赶紧想想我们之前讲过的变量的命名规则）。在函数\n名后面的圆括号中可以设置函数的参数，也就是我们刚才说的函数的自变量，而函数执行完成后，我们会通过return关键字来返回函数的执行结果，这就是我们刚才说的函数的\n因变量。如果函数中没有return语句，那么函数会返回代表空值的None。另外，函数也可以没有自变量（参数），但是函数名后面的圆括号是必须有的。一个函数要做的事\n情（要执行的代码），是通过代码缩进的方式放到函数定义行之后，跟之前分支和循环结构的代码块类似，如下图所示。\n\n下面，我们将之前代码中求阶乘的操作放到一个函数中，通过这种方式来重构上面的代码。所谓重构，是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下\n所示。\n\n\n\n大家可以感受下，上面的代码是不是比之前的版本更加简单优雅。更为重要的是，我们定义的求阶乘函数fac还可以在其他需要求阶乘的代码中重复使用。所以，使用函数可以帮助\n我们将功能上相对独立且会被重复使用的代码封装起来，当我们需要这些的代码，不是把重复的代码再编写一遍，而是通过调用函数实现对既有代码的复用。事实上，Python\n标准库的math模块中，已经有一个名为factorial的函数实现了求阶乘的功能，我们可以直接用import\nmath导入math模块，然后使用math.factorial来调用求阶乘的函数；我们也可以通过from math import\nfactorial直接导入factorial函数来使用它，代码如下所示。\n\n\n\n将来我们使用的函数，要么是自定义的函数，要么是 Python\n标准库或者三方库中提供的函数，如果已经有现成的可用的函数，我们就没有必要自己去定义，“重复发明轮子”是一件非常糟糕的事情。对于上面的代码，如果你觉得factor\nial这个名字太长，书写代码的时候不是特别方便，我们在导入函数的时候还可以通过as关键字为其别名。在调用函数的时候，我们可以用函数的别名，而不再使用它之前的名字\n，代码如下所示。\n\n\n\n\n函数的参数#\n\n位置参数和关键字参数#\n\n我们再来写一个函数，根据给出的三条边的长度判断是否可以构成三角形，如果可以构成三角形则返回True，否则返回False，代码如下所示。\n\n\n\n上面make_judgement函数有三个参数，这种参数叫做位置参数，在调用函数时通常按照从左到右的顺序依次传入，而且传入参数的数量必须和定义函数时参数的数量相\n同，如下所示。\n\n\n\n如果不想按照从左到右的顺序依次给出a、b、c 三个参数的值，也可以使用关键字参数，通过“参数名=参数值”的形式为函数传入参数，如下所示。\n\n\n\n在定义函数时，我们可以在参数列表中用/设置强制位置参数（positional-only\narguments），用*设置命名关键字参数。所谓强制位置参数，就是调用函数时只能按照参数位置来接收参数值的参数；而命名关键字参数只能通过“参数名=参数值”的方\n式来传递和接收参数，大家可以看看下面的例子。\n\n\n\n> 说明：强制位置参数是 Python 3.8 引入的新特性，在使用低版本的 Python 解释器时需要注意。\n\n\n\n参数的默认值#\n\nPython\n中允许函数的参数拥有默认值，我们可以把之前讲过的一个例子“CRAPS赌博游戏”（《第07课：分支和循环结构的应用》）中摇色子获得点数的功能封装到函数中，代码如下\n所示。\n\n\n\n我们再来看一个更为简单的例子。\n\n\n\n需要注意的是，带默认值的参数必须放在不带默认值的参数之后，否则将产生SyntaxError错误，错误消息是：non-default argument\nfollows default argument，翻译成中文的意思是“没有默认值的参数放在了带默认值的参数后面”。\n\n可变参数#\n\nPython\n语言中可以通过星号表达式语法让函数支持可变参数。所谓可变参数指的是在调用函数时，可以向函数传入0个或任意多个参数。将来我们以团队协作的方式开发商业项目时，很有可\n能要设计函数给其他人使用，但有的时候我们并不知道函数的调用者会向该函数传入多少个参数，这个时候可变参数就能派上用场。\n\n下面的代码演示了如何使用可变位置参数实现对任意多个数求和的add函数，调用函数时传入的参数会保存到一个元组，通过对该元组的遍历，可以获取传入函数的参数。\n\n\n\n如果我们希望通过“参数名=参数值”的形式传入若干个参数，具体有多少个参数也是不确定的，我们还可以给函数添加可变关键字参数，把传入的关键字参数组装到一个字典中，代\n码如下所示。\n\n\n\n输出：\n\n\n\n\n用模块管理函数#\n\n不管用什么样的编程语言来写代码，给变量、函数起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同\n名的函数，如下所示。\n\n\n\n当然上面的这种情况我们很容易就能避免，但是如果项目是团队协作多人开发的时候，团队中可能有多个程序员都定义了名为foo的函数，这种情况下怎么解决命名冲突呢？答案其\n实很简单，Python\n中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候，我们通过import关键字导入指定的模块再使用完全限定名（模块\n名.函数名）的调用方式，就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。\n\nmodule1.py\n\n\n\nmodule2.py\n\n\n\ntest.py\n\n\n\n在导入模块时，还可以使用as关键字对模块进行别名，这样我们可以使用更为简短的完全限定名。\n\ntest.py\n\n\n\n上面两段代码，我们导入的是定义函数的模块，我们也可以使用from...import...语法从模块中直接导入需要使用的函数，代码如下所示。\n\ntest.py\n\n\n\n但是，如果我们如果从两个不同的模块中导入了同名的函数，后面导入的函数会替换掉之前的导入，就像下面的代码，调用foo会输出goodbye,\nworld!，因为我们先导入了module1的foo，后导入了module2的foo 。如果两个from...import...反过来写，那就是另外一番光景了。\n\ntest.py\n\n\n\n如果想在上面的代码中同时使用来自两个模块的foo函数还是有办法的，大家可能已经猜到了，还是用as关键字对导入的函数进行别名，代码如下所示。\n\ntest.py\n\n\n\n\n标准库中的模块和函数#\n\nPython\n标准库中提供了大量的模块和函数来简化我们的开发工作，我们之前用过的random模块就为我们提供了生成随机数和进行随机抽样的函数；而time模块则提供了和时间操作\n相关的函数；我们之前用到过的math模块中还包括了计算正弦、余弦、指数、对数等一系列的数学函数。随着我们深入学习 Python\n语言，我们还会用到更多的模块和函数。\n\nPython\n标准库中还有一类函数是不需要import就能够直接使用的，我们将其称之为内置函数，这些内置函数不仅有用而且还很常用，下面的表格列出了一部分的内置函数。\n\n函数      说明\nabs     返回一个数的绝对值，例如：abs(-1.3)会返回1.3。\nbin     把一个整数转换成以'0b'开头的二进制字符串，例如：bin(123)会返回'0b1111011'。\nchr     将Unicode编码转换成对应的字符，例如：chr(8364)会返回'€'。\nhex     将一个整数转换成以'0x'开头的十六进制字符串，例如：hex(123)会返回'0x7b'。\ninput   从输入中读取一行，返回读到的字符串。\nlen     获取字符串、列表等的长度。\nmax     返回多个参数或一个可迭代对象中的最大值，例如：max(12, 95, 37)会返回95。\nmin     返回多个参数或一个可迭代对象中的最小值，例如：min(12, 95, 37)会返回12。\noct     把一个整数转换成以'0o'开头的八进制字符串，例如：oct(123)会返回'0o173'。\nopen    打开一个文件并返回文件对象。\nord     将字符转换成对应的Unicode编码，例如：ord('€')会返回8364。\npow     求幂运算，例如：pow(2, 3)会返回8；pow(2, 0.5)会返回1.4142135623730951。\nprint   打印输出。\nrange   构造一个范围序列，例如：range(100)会产生0到99的整数序列。\nround   按照指定的精度对数值进行四舍五入，例如：round(1.23456, 4)会返回1.2346。\nsum     对一个序列中的项从左到右进行求和运算，例如：sum(range(1, 101))会返回5050。\ntype    返回对象的类型，例如：type(10)会返回int；而 type('hello')会返回str。\n\n\n总结#\n\n函数是对功能相对独立且会重复使用的代码的封装。学会使用定义和使用函数，就能够写出更为优质的代码。当然，Python\n语言的标准库中已经为我们提供了大量的模块和常用的函数，用好这些模块和函数就能够用更少的代码做更多的事情；如果这些模块和函数不能满足我们的要求，可能就需要自定义函\n数，然后再通过模块的概念来管理这些自定义函数。",
    "routePath": "/tutorial/python/第14课：函数和模块",
    "lang": "",
    "toc": [
      {
        "text": "第14课：函数和模块",
        "id": "第14课函数和模块",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "定义函数",
        "id": "定义函数",
        "depth": 3,
        "charIndex": 578
      },
      {
        "text": "函数的参数",
        "id": "函数的参数",
        "depth": 3,
        "charIndex": 1725
      },
      {
        "text": "位置参数和关键字参数",
        "id": "位置参数和关键字参数",
        "depth": 4,
        "charIndex": 1733
      },
      {
        "text": "参数的默认值",
        "id": "参数的默认值",
        "depth": 4,
        "charIndex": 2191
      },
      {
        "text": "可变参数",
        "id": "可变参数",
        "depth": 4,
        "charIndex": 2448
      },
      {
        "text": "用模块管理函数",
        "id": "用模块管理函数",
        "depth": 3,
        "charIndex": 2782
      },
      {
        "text": "标准库中的模块和函数",
        "id": "标准库中的模块和函数",
        "depth": 3,
        "charIndex": 3529
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 4579
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 19,
    "title": "",
    "content": "第15课：函数的应用#\n\n\n案例1#\n\n设计一个生成随机验证码的函数，验证码由数字和英文大小写字母构成，长度可以通过参数设置。\n\n\n\n> 说明1：string模块的digits代表0到9的数字构成的字符串'0123456789'，string模块的ascii_letters代表大小写英文字母构\n> 成的字符串'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'。\n> \n> 说明2：random模块的sample和choices函数都可以实现随机抽样，sample实现无放回抽样，这意味着抽样取出的元素是不重复的；choices实\n> 现有放回抽样，这意味着可能会重复选中某些元素。这两个函数的第一个参数代表抽样的总体，而参数k代表样本容量，需要说明的是choices函数的参数k是一个命名关\n> 键字参数，在传参时必须指定参数名。\n\n可以用下面的代码生成5组随机验证码来测试上面的函数。\n\n\n\n输出：\n\n\n\n或者\n\n\n\n输出：\n\n\n\n> 说明：我们设计的generate_code函数的参数是命名关键字参数，由于它有默认值，可以不给它传值，使用默认值4。如果需要给函数传入参数，必须指定参数名c\n> ode_len。\n\n\n案例2#\n\n设计一个判断给定的大于1的正整数是不是质数的函数。质数是只能被1和自身整除的正整数（大于1），如果一个大于1的正整数$N$是质数，那就意味着在2到$N-1$之间\n都没有它的因子。\n\n\n\n> 说明1：上面is_prime函数的参数num后面的:\n> int用来标注参数的类型，虽然它对代码的执行结果不产生任何影响，但是很好的增强了代码的可读性。同理，参数列表后面的->\n> bool用来标注函数返回值的类型，它也不会对代码的执行结果产生影响，但是却让我们清楚的知道，调用函数会得到一个布尔值，要么是True，要么是False。\n> \n> 说明2：上面的循环并不需要从2循环到$\\small{N-1}$，因为如果循环进行到$\\small{\\sqrt{N}}$时，还没有找到$\\small{N}$的\n> 因子，那么$\\small{\\sqrt{N}}$之后也不会出现$\\small{N}$的因子，大家可以自己想一想这是为什么。\n\n\n案例3#\n\n设计计算两个正整数最大公约数和最小公倍数的函数。$x$和$y$的最大公约数是能够同时整除$x$和$y$的最大整数，如果$x$和$y$互质，那么它们的最大公约数为\n1；$x$和$y$的最小公倍数是能够同时被$x$和$y$整除的最小正整数，如果$x$和$y$互质，那么它们的最小公倍数为$x \\times\ny$。需要提醒大家注意的是，计算最大公约数和最小公倍数是两个不同的功能，应该设计成两个函数，而不是把两个功能放到同一个函数中。\n\n\n\n> 说明1：函数之间可以相互调用，上面求最小公倍数的lcm函数就调用了求最大公约数的gcd函数，通过$\\frac{x \\times y}{ gcd(x,\n> y)}$来计算最小公倍数。\n> \n> 说明2：上面的gcd函数使用了欧几里得算法计算最大公约数，欧几里得算法也称为辗转相除法，这个算法通常有更好的执行效率，不了解的小伙伴可以自行科普。\n\n\n案例4#\n\n假设样本数据保存一个列表中，设计计算样本数据描述性统计信息的函数。描述性统计信息通常包括：算术平均值、中位数、极差（最大值和最小值的差）、方差、标准差、变异系数\n等，计算公式如下所示：\n\n样本均值（sample mean）： $$ \\bar{x} = \\frac{\\sum_{i=1}^{n}x_{i}}{n} =\n\\frac{x_{1}+x_{2}+\\cdots +x_{n}}{n} $$ 样本方差（sample variance）： $$ s^2 = \\frac\n{\\sum_{i=1}^{n}(x_i - \\bar{x})^2} {n-1} $$ 样本标准差（sample standard deviation）： $$\ns = \\sqrt{\\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})^2}{n-1}} $$ 变异系数（coefficient of\nsample variation）： $$ CV = \\frac{s}{\\bar{x}} $$\n\n\n\n> 说明1：中位数是将数据按照升序或降序排列后位于中间的数，它描述了数据的中等水平。中位数的计算分两种情况：当数据体量$n$为奇数时，中位数是位于$\\frac{\n> n + 1}{2}$位置的元素；当数据体量$n$为偶数时，中位数是位于$\\frac{n}{2}$和$\\frac{n}{2} + 1$两个位置元素的均值。\n> \n> 说明2：计算方差和标准差的函数中有一个名为ddof的参数，它代表了可以调整的自由度，默认值为1。在计算样本方差和样本标准差时，需要进行自由度校正；如果要计算\n> 总体方差和总体标准差，可以将ddof参数赋值为0，即不需要进行自由度校正。\n> \n> 说明3：describe函数将上面封装好的统计函数组装到一起，用于输出数据的描述性统计信息。事实上，Python\n> 标准库中有一个名为statistics的模块，它已经把获取描述性统计信息的函数封装好了，有兴趣的读者可以自行了解。\n\n\n案例5#\n\n我们用函数重构之前讲过的双色球随机选号的例子（《第09课：常用数据结构之列表-2》），将生成随机号码和输出一组号码的功能分别封装到两个函数中，然后通过调用函数实\n现机选N注号码的功能。\n\n\n\n> 说明：大家看看display(choose())这行代码，这里我们先通过choose函数获得一组随机号码，然后把choose函数的返回值作为display函\n> 数的参数，通过display函数将选中的随机号码显示出来。重构之后的代码逻辑非常清晰，代码的可读性更强了。如果有人为你封装了这两个函数，你仅仅是函数的调用者\n> ，其实你根本不用关心choose函数和display函数的内部实现，你只需要知道调用choose函数可以生成一组随机号码，而调用display函数传入一个列\n> 表，就可以输出这组号码。将来我们使用各种各样的 Python 三方库时，我们也根本不关注它们的底层实现，我们需要知道的仅仅是调用哪个函数可以解决问题。\n\n\n总结#\n\n在写代码尤其是开发商业项目的时候，一定要有意识的将相对独立且重复使用的功能封装成函数，这样不管是自己还是团队的其他成员都可以通过调用函数的方式来使用这些功能，减\n少工作中那些重复且乏味的劳动。",
    "routePath": "/tutorial/python/第15课：函数的应用",
    "lang": "",
    "toc": [
      {
        "text": "第15课：函数的应用",
        "id": "第15课函数的应用",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "案例1",
        "id": "案例1",
        "depth": 3,
        "charIndex": 13
      },
      {
        "text": "案例2",
        "id": "案例2",
        "depth": 3,
        "charIndex": 540
      },
      {
        "text": "案例3",
        "id": "案例3",
        "depth": 3,
        "charIndex": 958
      },
      {
        "text": "案例4",
        "id": "案例4",
        "depth": 3,
        "charIndex": 1356
      },
      {
        "text": "案例5",
        "id": "案例5",
        "depth": 3,
        "charIndex": 2214
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2639
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 20,
    "title": "",
    "content": "第16课：函数使用进阶#\n\n我们继续探索定义和使用函数的相关知识。通过前面的学习，我们知道了函数有自变量（参数）和因变量（返回值），自变量可以是任意的数据类型，因变量也可以是任意的数据类型\n，那么这里就有一个小问题，我们能不能用函数作为函数的参数，用函数作为函数的返回值？这里我们先说结论：Python\n中的函数是“一等函数”，所谓“一等函数”指的就是函数可以赋值给变量，函数可以作为函数的参数，函数也可以作为函数的返回值。把一个函数作为其他函数的参数或返回值的用\n法，我们通常称之为“高阶函数”。\n\n\n高阶函数#\n\n我们回到之前讲过的一个例子，设计一个函数，传入任意多个参数，对其中int类型或float类型的元素实现求和操作。我们对之前的代码稍作调整，让整个代码更加紧凑一些\n，如下所示。\n\n\n\n如果我们希望上面的calc函数不仅仅可以做多个参数的求和，还可以实现更多的甚至是自定义的二元运算，我们该怎么做呢？上面的代码只能求和是因为函数中使用了+=运算符\n，这使得函数跟加法运算形成了耦合关系，如果能解除这种耦合关系，函数的通用性和灵活性就会更好。解除耦合的办法就是将+运算符变成函数调用，并将其设计为函数的参数，代\n码如下所示。\n\n\n\n注意，上面的函数增加了两个参数，其中init_value代表运算的初始值，op_func代表二元运算函数，为了调用修改后的函数，我们先定义做加法和乘法运算的函数\n，代码如下所示。\n\n\n\n如果要做求和的运算，我们可以按照下面的方式调用calc函数。\n\n\n\n如果要做求乘积运算，我们可以按照下面的方式调用calc函数。\n\n\n\n上面的calc函数通过将运算符变成函数的参数，实现了跟加法运算耦合，这是一种非常高明和实用的编程技巧，但对于最初学者来说可能会觉得难以理解，建议大家细品一下。需\n要注意上面的代码中，将函数作为参数传入其他函数和直接调用函数是有显著的区别的，调用函数需要在函数名后面跟上圆括号，而把函数作为参数时只需要函数名即可。\n\n如果我们没有提前定义好add和mul函数，也可以使用 Python\n标准库中的operator模块提供的add和mul函数，它们分别代表了做加法和做乘法的二元运算，我们拿过来直接使用即可，代码如下所示。\n\n\n\nPython\n内置函数中有不少高阶函数，我们前面提到过的filter和map函数就是高阶函数，前者可以实现对序列中元素的过滤，后者可以实现对序列中元素的映射，例如我们要去掉一\n个整数列表中的奇数，并对所有的偶数求平方得到一个新的列表，就可以直接使用这两个函数来做到，具体的做法是如下所示。\n\n\n\n当然，要完成上面代码的功能，也可以使用列表生成式，列表生成式的做法更为简单优雅。\n\n\n\n我们再来讨论一个内置函数sorted，它可以实现对容器型数据类型（如：列表、字典等）元素的排序。我们之前讲过list类型的sort方法，它实现了对列表元素的排序\n，sorted函数从功能上来讲跟列表的sort方法没有区别，但它会返回排序后的列表对象，而不是直接修改原来的列表，这一点我们称为函数的无副作用设计，也就是说调用\n函数除了产生返回值以外，不会对程序的状态或外部环境产生任何其他的影响。使用sorted函数排序时，可以通过高阶函数的形式自定义排序的规则，我们通过下面的例子加以\n说明。\n\n\n\n上面的代码对大家来说并不陌生，但是如果希望根据字符串的长度而不是字母表顺序对列表元素排序，我们可以向sorted函数传入一个名为key的参数，将key参数赋值为\n获取字符串长度的函数len，这个函数我们在之前的课程中讲到过，代码如下所示。\n\n\n\n> 说明：列表类型的sort方法也有同样的key参数，有兴趣的读者可以自行尝试。\n\n\nLambda函数#\n\n在使用高阶函数的时候，如果作为参数或者返回值的函数本身非常简单，一行代码就能够完成，也不需要考虑对函数的复用，那么我们可以使用 lambda 函数。Python\n中的 lambda 函数是没有的名字函数，所以很多人也把它叫做匿名函数，lambda\n函数只能有一行代码，代码中的表达式产生的运算结果就是这个匿名函数的返回值。之前的代码中，我们写的is_even和square函数都只有一行代码，我们可以考虑用\nlambda 函数来替换掉它们，代码如下所示。\n\n\n\n通过上面的代码可以看出，定义 lambda\n函数的关键字是lambda，后面跟函数的参数，如果有多个参数用逗号进行分隔；冒号后面的部分就是函数的执行体，通常是一个表达式，表达式的运算结果就是 lambda\n函数的返回值，不需要写return 关键字。\n\n前面我们说过，Python 中的函数是“一等函数”，函数是可以直接赋值给变量的。在学习了 lambda\n函数之后，前面我们写过的一些函数就可以用一行代码来实现它们了，大家可以看看能否理解下面的求阶乘和判断素数的函数。\n\n\n\n> 提示1：上面使用的reduce函数是 Python\n> 标准库functools模块中的函数，它可以实现对一组数据的归约操作，类似于我们之前定义的calc函数，第一个参数是代表运算的函数，第二个参数是运算的数据，\n> 第三个参数是运算的初始值。很显然，reduce函数也是高阶函数，它和filter函数、map函数一起构成了处理数据中非常关键的三个动作：过滤、映射和归约。\n> \n> 提示2：上面判断素数的 lambda\n> 函数通过range函数构造了从$\\small{2}$到$\\small{\\sqrt{x}}$的范围，检查这个范围有没有x的因子。all函数也是 Python\n> 内置函数，如果传入的序列中所有的布尔值都是True，all函数返回True，否则all函数返回False。\n\n\n偏函数#\n\n偏函数是指固定函数的某些参数，生成一个新的函数，这样就无需在每次调用函数时都传递相同的参数。在 Python\n语言中，我们可以使用functools模块的partial函数来创建偏函数。例如，int函数在默认情况下可以将字符串视为十进制整数进行类型转换，如果我们修修改它\n的base参数，就可以定义出三个新函数，分别用于将二进制、八进制、十六进制字符串转换为整数，代码如下所示。\n\n\n\n不知大家是否注意到，partial函数的第一个参数和返回值都是函数，它将传入的函数处理成一个新的函数返回。通过构造偏函数，我们可以结合实际的使用场景将原函数变成\n使用起来更为便捷的新函数，不知道大家有没有觉得这波操作很有意思。\n\n\n总结#\n\nPython 中的函数是一等函数，可以赋值给变量，也可以作为函数的参数和返回值，这也就意味着我们可以在 Python\n中使用高阶函数。高阶函数的概念对新手并不友好，但它却带来了函数设计上的灵活性。如果我们要定义的函数非常简单，只有一行代码，而且不需要函数名来复用它，我们可以使用\nlambda 函数。",
    "routePath": "/tutorial/python/第16课：函数使用进阶",
    "lang": "",
    "toc": [
      {
        "text": "第16课：函数使用进阶",
        "id": "第16课函数使用进阶",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "高阶函数",
        "id": "高阶函数",
        "depth": 3,
        "charIndex": 251
      },
      {
        "text": "Lambda函数",
        "id": "lambda函数",
        "depth": 3,
        "charIndex": 1553
      },
      {
        "text": "偏函数",
        "id": "偏函数",
        "depth": 3,
        "charIndex": 2385
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2700
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 21,
    "title": "",
    "content": "第17课：函数高级应用#\n\n在上一个章节中，我们探索了 Python 中的高阶函数，相信大家对函数的定义和应用有了更深刻的认知。本章我们继续为大家讲解函数相关的知识，一个是 Python\n中的特色语法装饰器，一个是函数的递归调用。\n\n\n装饰器#\n\nPython\n语言中，装饰器是“用一个函数装饰另外一个函数并为其提供额外的能力”的语法现象。装饰器本身是一个函数，它的参数是被装饰的函数，它的返回值是一个带有装饰功能的函数。\n通过前面的描述，相信大家已经听出来了，装饰器是一个高阶函数，它的参数和返回值都是函数。但是，装饰器的概念对编程语言的初学者来说，还是让人头疼的，下面我们先通过一\n个简单的例子来说明装饰器的作用。假设有名为downlaod和upload的两个函数，分别用于文件的上传和下载，如下所示。\n\n\n\n> 说明：上面的代码用休眠一段随机时间的方式模拟了下载和上传文件需要花费一定的时间，并没有真正的联网上传下载文件。用 Python\n> 语言实现联网上传下载文件也非常简单，后面我们会讲到相关的知识。\n\n现在有一个新的需求，我们希望知道调用download和upload函数上传下载文件到底用了多少时间，这应该如何实现呢？相信很多小伙伴已经想到了，我们可以在函数开\n始执行的时候记录一个时间，在函数调用结束后记录一个时间，两个时间相减就可以计算出下载或上传的时间，代码如下所示。\n\n\n\n通过上面的代码，我们可以在下载和上传文件时记录下耗费的时间，但不知道大家是否注意到，上面记录时间、计算和显示执行时间的代码都是重复代码。有编程经验的人都知道，重\n复的代码是万恶之源，那么有没有办法在不写重复代码的前提下，用一种简单优雅的方式记录下函数的执行时间呢？在 Python\n语言中，装饰器就是解决这类问题的最佳选择。通过装饰器语法，我们可以把跟原来的业务（上传和下载）没有关系计时功能的代码封装到一个函数中，如果upload和down\nload函数需要记录时间，我们直接把装饰器作用到这两个函数上即可。既然上面提到了，装饰器是一个高阶函数，它的参数和返回值都是函数，我们将记录时间的装饰器姑且命名\n为record_time，那么它的整体结构应该如下面的代码所示。\n\n\n\n相信大家注意到了，record_time函数的参数func代表了一个被装饰的函数，函数里面定义的wrapper函数是带有装饰功能的函数，它会执行被装饰的函数fu\nnc，它还需要返回在最后产生函数执行的返回值。不知大家是否留意到，上面的代码我在第4行和第6行留下了两个空行，这意味着我们可以这些地方添加代码来实现额外的功能。\nrecord_time函数最终会返回这个带有装饰功能的函数wrapper并通过它替代原函数func，当原函数func被record_time函数装饰后，我们调用\n它时其实调用的是wrapper函数，所以才获得了额外的能力。wrapper函数的参数比较特殊，由于我们要用wrapper替代原函数func，但是我们又不清楚原函\n数func会接受哪些参数，所以我们就通过可变参数和关键字参数照单全收，然后在调用func的时候，原封不动的全部给它。这里还要强调一下，Python\n语言支持函数的嵌套定义，就像上面，我们可以在record_time函数中定义wrapper函数，这个操作在很多编程语言中并不被支持。\n\n看懂这个结构后，我们就可以把记录时间的功能写到这个装饰器中，代码如下所示。\n\n\n\n写装饰器虽然颇费周折，但是这是个一劳永逸的骚操作，将来再有记录函数执行时间的需求时，我们只需要添加上面的装饰器即可。使用上面的装饰器函数有两种方式，第一种方式就\n是直接调用装饰器函数，传入被装饰的函数并获得返回值，我们可以用这个返回值直接替代原来的函数，那么在调用时就已经获得了装饰器提供的额外的能力（记录执行时间），大家\n试试下面的代码就明白了。\n\n\n\n在 Python\n中，使用装饰器很有更为便捷的语法糖（编程语言中添加的某种语法，这种语法对语言的功能没有影响，但是使用更加方法，代码的可读性也更强，我们将其称之为“语法糖”或“糖\n衣语法”），可以用@装饰器函数将装饰器函数直接放在被装饰的函数上，效果跟上面的代码相同。我们把完整的代码为大家罗列出来，大家可以再看看我们是如何定义和使用装饰器\n的。\n\n\n\n上面的代码，我们通过装饰器语法糖为download和upload函数添加了装饰器，被装饰后的download和upload函数其实就是我们在装饰器中返回的wra\npper函数，调用它们其实就是在调用wrapper函数，所以才有了记录函数执行时间的功能。\n\n如果在代码的某些地方，我们想去掉装饰器的作用执行原函数，那么在定义装饰器函数的时候，需要做一点点额外的工作。Python\n标准库functools模块的wraps函数也是一个装饰器，我们将它放在wrapper函数上，这个装饰器可以帮我们保留被装饰之前的函数，这样在需要取消装饰器时，\n可以通过被装饰函数的__wrapped__属性获得被装饰之前的函数。\n\n\n\n装饰器函数本身也可以参数化，简单的说就是装饰器也是可以通过调用者传入的参数来进行定制的，这个知识点我们在后面用到的时候再为大家讲解。\n\n\n递归调用#\n\nPython\n中允许函数嵌套定义，也允许函数之间相互调用，而且一个函数还可以直接或间接的调用自身。函数自己调用自己称为递归调用，那么递归调用有什么用处呢？现实中，有很多问题的\n定义本身就是一个递归定义，例如我们之前讲到的阶乘，非负整数N的阶乘是N乘以N-1的阶乘，即$\\small{N! = N \\times\n(N-1)!}$，定义的左边和右边都出现了阶乘的概念，所以这是一个递归定义。既然如此，我们可以使用递归调用的方式来写一个求阶乘的函数，代码如下所示。\n\n\n\n上面的代码中，fac函数中又调用了fac函数，这就是所谓的递归调用。代码第2行的if条件叫做递归的收敛条件，简单的说就是什么时候要结束函数的递归调用，在计算阶乘\n时，如果计算到0或1的阶乘，就停止递归调用，直接返回1；代码第4行的num * fac(num -\n1)是递归公式，也就是阶乘的递归定义。下面，我们简单的分析下，如果用fac(5)计算5的阶乘，整个过程会是怎样的。\n\n\n\n注意，函数调用会通过内存中称为“栈”（stack）的数据结构来保存当前代码的执行现场，函数调用结束后会通过这个栈结构恢复之前的执行现场。栈是一种先进后出的数据结\n构，这也就意味着最早入栈的函数最后才会返回，而最后入栈的函数会最先返回。例如调用一个名为a的函数，函数a的执行体中又调用了函数b，函数b的执行体中又调用了函数c\n，那么最先入栈的函数是a，最先出栈的函数是c。每进入一个函数调用，栈就会增加一层栈帧（stack\nframe），栈帧就是我们刚才提到的保存当前代码执行现场的结构；每当函数调用结束后，栈就会减少一层栈帧。通常，内存中的栈空间很小，因此递归调用的次数如果太多，会\n导致栈溢出（stack\noverflow），所以递归调用一定要确保能够快速收敛。我们可以尝试执行fac(5000)，看看是不是会提示RecursionError错误，错误消息为：max\nimum recursion depth exceeded in comparison（超出最大递归深度），其实就是发生了栈溢出。\n\n如果我们使用官方的 Python\n解释器（CPython），默认将函数调用的栈结构最大深度设置为1000层。如果超出这个深度，就会发生上面说的RecursionError。当然，我们可以使用sy\ns模块的setrecursionlimit函数来改变递归调用的最大深度，但是我们不建议这样做，因为让递归快速收敛才是我们应该做的事情，否则就应该考虑使用循环递推\n而不是递归。\n\n再举一个之前讲过的生成斐波那契数列的例子，因为斐波那契数列前两个数都是1，从第三个数开始，每个数是前两个数相加的和，可以记为f(n) = f(n - 1) +\nf(n - 2)，很显然这又是一个递归的定义，所以我们可以用下面的递归调用函数来计算第 n个斐波那契数。\n\n\n\n需要提醒大家，上面计算斐波那契数的代码虽然看起来非常简单明了，但执行性能是比较糟糕的。大家可以试一试，把上面代码for循环中range函数的第二个参数修改为51\n，即输出前50个斐波那契数，看看需要多长时间，也欢迎大家在评论区留下你的代码执行时间。至于为什么这么慢，大家可以自己思考一下原因。很显然，直接使用循环递推的方式\n获得斐波那契数列是更好的选择，代码如下所示。\n\n\n\n除此以外，我们还可以使用 Python\n标准库中functools模块的lru_cache函数来优化上面的递归代码。lru_cache函数是一个装饰器函数，我们将其置于上面的函数fib1之上，它可以缓\n存该函数的执行结果从而避免在递归调用的过程中产生大量的重复运算，这样代码的执行性能就有“飞一般”的提升。大家可以尝试输出前50个斐波那契数，看看加上装饰器以后代\n码需要执行多长时间，评论区见！\n\n\n\n> 提示：lru_cache函数是一个带参数的装饰器，所以上面第4行代码使用装饰器语法糖时，lru_cache后面要跟上圆括号。lru_cache函数有一个非常\n> 重要的参数叫maxsize，它可以用来定义缓存空间的大小，默认值是128。\n\n\n总结#\n\n装饰器是 Python\n语言中的特色语法，可以通过装饰器来增强现有的函数，这是一种非常有用的编程技巧。另一方面，通过函数递归调用，可以在代码层面将一些复杂的问题简单化，但是递归调用一定\n要注意收敛条件和递归公式，找到递归公式才有机会使用递归调用，而收敛条件则确保了递归调用能停下来。函数调用通过内存中的栈空间来保存现场和恢复现场，栈空间通常都很小\n，所以递归如果不能迅速收敛，很可能会引发栈溢出错误，从而导致程序的崩溃。",
    "routePath": "/tutorial/python/第17课：函数高级应用",
    "lang": "",
    "toc": [
      {
        "text": "第17课：函数高级应用",
        "id": "第17课函数高级应用",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "装饰器",
        "id": "装饰器",
        "depth": 3,
        "charIndex": 117
      },
      {
        "text": "递归调用",
        "id": "递归调用",
        "depth": 3,
        "charIndex": 2176
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3895
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 22,
    "title": "",
    "content": "第18课：面向对象编程入门#\n\n面向对象编程是一种非常流行的编程范式（programming\nparadigm），所谓编程范式就是程序设计的方法论，简单的说就是程序员对程序的认知和理解以及他们编写代码的方式。\n\n在前面的课程中，我们说过“程序是指令的集合”，运行程序时，程序中的语句会变成一条或多条指令，然后由CPU（中央处理器）去执行。为了简化程序的设计，我们又讲到了函\n数，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些代码的时候调用函数即可。如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数进一步拆分为多个子\n函数来降低系统的复杂性。\n\n不知大家是否发现，编程其实是写程序的人按照计算机的工作方式通过代码控制机器完成任务。但是，计算机的工作方式与人类正常的思维模式是不同的，如果编程就必须抛弃人类正\n常的思维方式去迎合计算机，编程的乐趣就少了很多。这里，我想说的并不是我们不能按照计算机的工作方式去编写代码，但是当我们需要开发一个复杂的系统时，这种方式会让代码\n过于复杂，从而导致开发和维护工作都变得举步维艰。\n\n随着软件复杂性的增加，编写正确可靠的代码会变成了一项极为艰巨的任务，这也是很多人都坚信“软件开发是人类改造世界所有活动中最为复杂的活动”的原因。如何用程序描述复\n杂系统和解决复杂问题，就成为了所有程序员必须要思考和直面的问题。诞生于上世纪70年代的 Smalltalk\n语言让软件开发者看到了希望，因为它引入了一种新的编程范式叫面向对象编程。在面向对象编程的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为对象，\n对象可以接收消息，解决问题的方法就是创建对象并向对象发出各种各样的消息；通过消息传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。\n当然，面向对象编程的雏形还可以向前追溯到更早期的Simula语言，但这不是我们要讨论的重点。\n\n> 说明：\n> 今天我们使用的很多高级程序设计语言都支持面向对象编程，但是面向对象编程也不是解决软件开发中所有问题的“银弹”，或者说在软件开发这个行业目前还没有所谓的“银弹\n> ”。关于这个问题，大家可以参考 IBM360\n> 系统之父弗雷德里克·布鲁克斯所发表的论文《没有银弹：软件工程的本质性与附属性工作》或软件工程的经典著作《人月神话》一书。\n\n\n类和对象#\n\n如果要用一句话来概括面向对象编程，我认为下面的说法是相当精辟和准确的。\n\n> 面向对象编程：把一组数据和处理数据的方法组成对象，把行为相同的对象归纳为类，通过封装隐藏对象的内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型\n> 的动态分派。\n\n这句话对初学者来说可能不那么容易理解，但是我可以先为大家圈出几个关键词：对象（object）、类（class）、封装（encapsulation）、继承（inh\neritance）、多态（polymorphism）。\n\n我们先说说类和对象这两个词。在面向对象编程中，类是一个抽象的概念，对象是一个具体的概念。我们把同一类对象的共同特征抽取出来就是一个类，比如我们经常说的人类，这是\n一个抽象概念，而我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，类是对象的蓝图和模板，对象是类的实例，是可以接受消息的实体。\n\n在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类。对象的属性是对象的静态特征，对象的行为是对象的动态特征\n。按照上面的说法，如果我们把拥有共同特征的对象的属性和行为都抽取出来，就可以定义出一个类。\n\n\n定义类#\n\n在 Python\n语言中，我们可以使用class关键字加上类名来定义类，通过缩进我们可以确定类的代码块，就如同定义函数那样。在类的代码块中，我们需要写一些函数，我们说过类是一个抽\n象概念，那么这些函数就是我们对一类对象共同的动态特征的提取。写在类里面的函数我们通常称之为方法，方法就是对象的行为，也就是对象可以接收的消息。方法的第一个参数通\n常都是self，它代表了接收这个消息的对象本身。\n\n\n\n\n创建和使用对象#\n\n在我们定义好一个类之后，可以使用构造器语法来创建对象，代码如下所示。\n\n\n\n在类的名字后跟上圆括号就是所谓的构造器语法，上面的代码创建了两个学生对象，一个赋值给变量stu1，一个赋值给变量stu2。当我们用print函数打印stu1和s\ntu2两个变量时，我们会看到输出了对象在内存中的地址（十六进制形式），跟我们用id函数查看对象标识获得的值是相同的。现在我们可以告诉大家，我们定义的变量其实保存\n的是一个对象在内存中的逻辑地址（位置），通过这个逻辑地址，我们就可以在内存中找到这个对象。所以stu3 =\nstu2这样的赋值语句并没有创建新的对象，只是用一个新的变量保存了已有对象的地址。\n\n接下来，我们尝试给对象发消息，即调用对象的方法。刚才的Student类中我们定义了study和play两个方法，两个方法的第一个参数self代表了接收消息的学生\n对象，study方法的第二个参数是学习的课程名称。Python中，给对象发消息有两种方式，请看下面的代码。\n\n\n\n\n初始化方法#\n\n大家可能已经注意到了，刚才我们创建的学生对象只有行为没有属性，如果要给学生对象定义属性，我们可以修改Student类，为其添加一个名为__init__的方法。在\n我们调用Student类的构造器创建对象时，首先会在内存中获得保存学生对象所需的内存空间，然后通过自动执行__init__方法，完成对内存的初始化操作，也就是把\n数据放到内存空间中。所以我们可以通过给Student类添加__init__方法的方式为学生对象指定属性，同时完成对属性赋初始值的操作，正因如此，__init__\n方法通常也被称为初始化方法。\n\n我们对上面的Student类稍作修改，给学生对象添加name（姓名）和age（年龄）两个属性。\n\n\n\n修改刚才创建对象和给对象发消息的代码，重新执行一次，看看程序的执行结果有什么变化。\n\n\n\n\n面向对象的支柱#\n\n面向对象编程有三大支柱，就是我们之前给大家划重点的时候圈出的三个词：封装、继承和多态。后面两个概念在下一节课中会详细说明，这里我们先说一下什么是封装。我自己对封\n装的理解是：隐藏一切可以隐藏的实现细节，只向外界暴露简单的调用接口。我们在类中定义的对象方法其实就是一种封装，这种封装可以让我们在创建对象之后，只需要给对象发送\n一个消息就可以执行方法中的代码，也就是说我们在只知道方法的名字和参数（方法的外部视图），不知道方法内部实现细节（方法的内部视图）的情况下就完成了对方法的使用。\n\n举一个例子，假如要控制一个机器人帮我倒杯水，如果不使用面向对象编程，不做任何的封装，那么就需要向这个机器人发出一系列的指令，如站起来、向左转、向前走5步、拿起面\n前的水杯、向后转、向前走10步、弯腰、放下水杯、按下出水按钮、等待10秒、松开出水按钮、拿起水杯、向右转、向前走5步、放下水杯等，才能完成这个简单的操作，想想都\n觉得麻烦。按照面向对象编程的思想，我们可以将倒水的操作封装到机器人的一个方法中，当需要机器人帮我们倒水的时候，只需要向机器人对象发出倒水的消息就可以了，这样做不\n是更好吗？\n\n在很多场景下，面向对象编程其实就是一个三步走的问题。第一步定义类，第二步创建对象，第三步给对象发消息。当然，有的时候我们是不需要第一步的，因为我们想用的类可能已\n经存在了。之前我们说过，Python内置的list、set、dict其实都是类，如果要创建列表、集合、字典对象，我们就不用自定义类了。当然，有的类并不是\nPython\n标准库中直接提供的，它可能来自于第三方的代码，如何安装和使用三方代码在后续课程中会进行讨论。在某些特殊的场景中，我们会用到名为“内置对象”的对象，所谓“内置对象\n”就是说上面三步走的第一步和第二步都不需要了，因为类已经存在而且对象已然创建过了，直接向对象发消息就可以了，这也就是我们常说的“开箱即用”。\n\n\n面向对象案例#\n\n案例1：定义一个类描述数字时钟。#\n\n\n\n案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。#\n\n\n\n\n总结#\n\n面向对象编程是一种非常流行的编程范式，除此之外还有指令式编程、函数式编程等编程范式。由于现实世界是由对象构成的，而对象是可以接收消息的实体，所以面向对象编程更符\n合人类正常的思维习惯。类是抽象的，对象是具体的，有了类就能创建对象，有了对象就可以接收消息，这就是面向对象编程的基础。定义类的过程是一个抽象的过程，找到对象公共\n的属性属于数据抽象，找到对象公共的方法属于行为抽象。抽象的过程是一个仁者见仁智者见智的过程，对同一类对象进行抽象可能会得到不同的结果，如下图所示。\n\n> 说明： 本节课的插图来自于 Grady Booc\n> 等撰写的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。",
    "routePath": "/tutorial/python/第18课：面向对象编程入门",
    "lang": "",
    "toc": [
      {
        "text": "第18课：面向对象编程入门",
        "id": "第18课面向对象编程入门",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "类和对象",
        "id": "类和对象",
        "depth": 3,
        "charIndex": 991
      },
      {
        "text": "定义类",
        "id": "定义类",
        "depth": 3,
        "charIndex": 1525
      },
      {
        "text": "创建和使用对象",
        "id": "创建和使用对象",
        "depth": 3,
        "charIndex": 1731
      },
      {
        "text": "初始化方法",
        "id": "初始化方法",
        "depth": 3,
        "charIndex": 2177
      },
      {
        "text": "面向对象的支柱",
        "id": "面向对象的支柱",
        "depth": 3,
        "charIndex": 2541
      },
      {
        "text": "面向对象案例",
        "id": "面向对象案例",
        "depth": 3,
        "charIndex": 3363
      },
      {
        "text": "案例1：定义一个类描述数字时钟。",
        "id": "案例1定义一个类描述数字时钟",
        "depth": 4,
        "charIndex": 3372
      },
      {
        "text": "案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。",
        "id": "案例2定义一个类描述平面上的点要求提供计算到另一个点距离的方法",
        "depth": 4,
        "charIndex": 3393
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 3433
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 23,
    "title": "",
    "content": "第19课：面向对象编程进阶#\n\n前面我们讲解了 Python 面向对象编程的一些基础知识，本节我们继续讨论面向对象编程相关的内容。\n\n\n可见性和属性装饰器#\n\n在很多面向对象编程语言中，对象的属性通常会被设置为私有（private）或受保护（protected）的成员，简单的说就是不允许直接访问这些属性；对象的方法通常\n都是公开的（public），因为公开的方法是对象能够接受的消息，也是对象暴露给外界的调用接口，这就是所谓的访问可见性。在 Python\n中，可以通过给对象属性名添加前缀下划线的方式来说明属性的访问可见性，例如，可以用__name表示一个私有属性，_name表示一个受保护属性，代码如下所示。\n\n\n\n上面代码的最后一行会引发AttributeError（属性错误）异常，异常消息为：'Student' object has no attribute\n'__name'。由此可见，以__开头的属性__name相当于是私有的，在类的外面无法直接访问，但是类里面的study方法中可以通过self.__name访问该\n属性。需要说明的是，大多数使用 Python 语言的人在定义类时，通常不会选择让对象的属性私有或受保护，正如有一句名言说的：“We are all\nconsenting adults here”（大家都是成年人），成年人可以为自己的行为负责，而不需要通过 Python\n语言本身来限制访问可见性。事实上，大多数的程序员都认为开放比封闭要好，把对象的属性私有化并非必不可少的东西，所以 Python\n语言并没有从语义上做出最严格的限定，也就是说上面的代码如果你愿意，用stu._Student__name的方式仍然可以访问到私有属性__name，有兴趣的读者可\n以自己试一试。\n\n\n动态属性#\n\nPython\n语言属于动态语言，维基百科对动态语言的解释是：“在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化”\n。动态语言非常灵活，目前流行的 Python 和 JavaScript 都是动态语言，除此之外，诸如 PHP、Ruby 等也都属于动态语言，而 C、C++\n等语言则不属于动态语言。\n\n在 Python 中，我们可以动态为对象添加属性，这是 Python\n作为动态类型语言的一项特权，代码如下所示。需要提醒大家的是，对象的方法其实本质上也是对象的属性，如果给对象发送一个无法接收的消息，引发的异常仍然是Attribu\nteError。\n\n\n\n如果不希望在使用对象时动态的为对象添加属性，可以使用 Python 语言中的__slots__魔法。对于Student类来说，可以在类中指定__slots__\n= ('name', 'age')，这样Student类的对象只能有name和age属性，如果想动态添加其他属性将会引发异常，代码如下所示。\n\n\n\n\n静态方法和类方法#\n\n之前我们在类中定义的方法都是对象方法，换句话说这些方法都是对象可以接收的消息。除了对象方法之外，类中还可以有静态方法和类方法，这两类方法是发给类的消息，二者并没\n有实质性的区别。在面向对象的世界里，一切皆为对象，我们定义的每一个类其实也是一个对象，而静态方法和类方法就是发送给类对象的消息。那么，什么样的消息会直接发送给类\n对象呢？\n\n举一个例子，定义一个三角形类，通过传入三条边的长度来构造三角形，并提供计算周长和面积的方法。计算周长和面积肯定是三角形对象的方法，这一点毫无疑问。但是在创建三角\n形对象时，传入的三条边长未必能构造出三角形，为此我们可以先写一个方法来验证给定的三条边长是否可以构成三角形，这种方法很显然就不是对象方法，因为在调用这个方法时三\n角形对象还没有创建出来。我们可以把这类方法设计为静态方法或类方法，也就是说这类方法不是发送给三角形对象的消息，而是发送给三角形类的消息，代码如下所示。\n\n\n\n上面的代码使用staticmethod装饰器声明了is_valid方法是Triangle类的静态方法，如果要声明类方法，可以使用classmethod装饰器（如\n上面的代码15~18行所示）。可以直接使用类名.方法名的方式来调用静态方法和类方法，二者的区别在于，类方法的第一个参数是类对象本身，而静态方法则没有这个参数。简\n单的总结一下，对象方法、类方法、静态方法都可以通过“类名.方法名”的方式来调用，区别在于方法的第一个参数到底是普通对象还是类对象，还是没有接受消息的对象。静态方\n法通常也可以直接写成一个独立的函数，因为它并没有跟特定的对象绑定。\n\n这里做一个补充说明，我们可以给上面计算三角形周长和面积的方法添加一个property装饰器（Python\n内置类型），这样三角形类的perimeter和area就变成了两个属性，不再通过调用方法的方式来访问，而是用对象访问属性的方式直接获得，修改后的代码如下所示。\n\n\n\n\n继承和多态#\n\n面向对象的编程语言支持在已有类的基础上创建新类，从而减少重复代码的编写。提供继承信息的类叫做父类（超类、基类），得到继承信息的类叫做子类（派生类、衍生类）。例如\n，我们定义一个学生类和一个老师类，我们会发现他们有大量的重复代码，而这些重复代码都是老师和学生作为人的公共属性和行为，所以在这种情况下，我们应该先定义人类，再通\n过继承，从人类派生出老师类和学生类，代码如下所示。\n\n\n\n继承的语法是在定义类的时候，在类名后的圆括号中指定当前类的父类。如果定义一个类的时候没有指定它的父类是谁，那么默认的父类是object类。object类是\nPython 中的顶级类，这也就意味着所有的类都是它的子类，要么直接继承它，要么间接继承它。Python\n语言允许多重继承，也就是说一个类可以有一个或多个父类，关于多重继承的问题我们在后面会有更为详细的讨论。在子类的初始化方法中，我们可以通过super().__in\nit__()来调用父类初始化方法，super函数是 Python\n内置函数中专门为获取当前对象的父类对象而设计的。从上面的代码可以看出，子类除了可以通过继承得到父类提供的属性和方法外，还可以定义自己特有的属性和方法，所以子类比\n父类拥有的更多的能力。在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，也叫做“里氏替换原则”（Liskov\nSubstitution Principle）。\n\n子类继承父类的方法后，还可以对方法进行重写（重新实现该方法），不同的子类可以对父类的同一个方法给出不同的实现版本，这样的方法在程序运行时就会表现出多态行为（调用\n相同的方法，做了不同的事情）。多态是面向对象编程中最精髓的部分，当然也是对初学者来说最难以理解和灵活运用的部分，我们会在下一个章节用专门的例子来讲解这个知识点。\n\n\n总结#\n\nPython 是动态类型语言，Python\n中的对象可以动态的添加属性，对象的方法其实也是属性，只不过和该属性对应的是一个可以调用的函数。在面向对象的世界中，一切皆为对象，我们定义的类也是对象，所以类也可\n以接收消息，对应的方法是类方法或静态方法。通过继承，我们可以从已有的类创建新类，实现对已有类代码的复用。",
    "routePath": "/tutorial/python/第19课：面向对象编程进阶",
    "lang": "",
    "toc": [
      {
        "text": "第19课：面向对象编程进阶",
        "id": "第19课面向对象编程进阶",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "可见性和属性装饰器",
        "id": "可见性和属性装饰器",
        "depth": 3,
        "charIndex": 67
      },
      {
        "text": "动态属性",
        "id": "动态属性",
        "depth": 3,
        "charIndex": 755
      },
      {
        "text": "静态方法和类方法",
        "id": "静态方法和类方法",
        "depth": 3,
        "charIndex": 1225
      },
      {
        "text": "继承和多态",
        "id": "继承和多态",
        "depth": 3,
        "charIndex": 2060
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2850
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  },
  {
    "id": 24,
    "title": "",
    "content": "第20课：面向对象编程应用#\n\n面向对象编程对初学者来说不难理解但很难应用，虽然我们为大家总结过面向对象的三步走方法（定义类、创建对象、给对象发消息），但是说起来容易做起来难。大量的编程练习和\n阅读优质的代码可能是这个阶段最能够帮助到大家的两件事情。接下来我们还是通过经典的案例来剖析面向对象编程的知识，同时也通过这些案例把我们之前学过的 Python\n知识都串联起来。\n\n\n经典案例#\n\n案例1：扑克游戏。#\n\n> 说明：简单起见，我们的扑克只有52张牌（没有大小王），游戏需要将52张牌发到4个玩家的手上，每个玩家手上有13张牌，按照黑桃、红心、草花、方块的顺序和点数从\n> 小到大排列，暂时不实现其他的功能。\n\n使用面向对象编程方法，首先需要从问题的需求中找到对象并抽象出对应的类，此外还要找到对象的属性和行为。当然，这件事情并不是特别困难，我们可以从需求的描述中找出名词\n和动词，名词通常就是对象或者是对象的属性，而动词通常是对象的行为。扑克游戏中至少应该有三类对象，分别是牌、扑克和玩家，牌、扑克、玩家三个类也并不是孤立的。类和类\n之间的关系可以粗略的分为is-a关系（继承）、has-a关系（关联）和use-a关系（依赖）。很显然扑克和牌是has-a关系，因为一副扑克有（has-a）52张\n牌；玩家和牌之间不仅有关联关系还有依赖关系，因为玩家手上有（has-a）牌而且玩家使用了（use-a）牌。\n\n牌的属性显而易见，有花色和点数。我们可以用0到3的四个数字来代表四种不同的花色，但是这样的代码可读性会非常糟糕，因为我们并不知道黑桃、红心、草花、方块跟0到3的\n数字的对应关系。如果一个变量的取值只有有限多个选项，我们可以使用枚举。与 C、Java 等语言不同的是，Python\n中没有声明枚举类型的关键字，但是可以通过继承enum模块的Enum类来创建枚举类型，代码如下所示。\n\n\n\n通过上面的代码可以看出，定义枚举类型其实就是定义符号常量，如SPADE、HEART等。每个符号常量都有与之对应的值，这样表示黑桃就可以不用数字0，而是用Suit\ne.SPADE；同理，表示方块可以不用数字3，\n而是用Suite.DIAMOND。注意，使用符号常量肯定是优于使用字面常量的，因为能够读懂英文就能理解符号常量的含义，代码的可读性会提升很多。Python\n中的枚举类型是可迭代类型，简单的说就是可以将枚举类型放到for-in循环中，依次取出每一个符号常量及其对应的值，如下所示。\n\n\n\n接下来我们可以定义牌类。\n\n\n\n可以通过下面的代码来测试下Card类。\n\n\n\n接下来我们定义扑克类。\n\n\n\n可以通过下面的代码来测试下Poker类。\n\n\n\n定义玩家类。\n\n\n\n创建四个玩家并将牌发到玩家的手上。\n\n\n\n执行上面的代码会在player.arrange()那里出现异常，因为Player的arrange方法使用了列表的sort对玩家手上的牌进行排序，排序需要比较两个\nCard对象的大小，而<运算符又不能直接作用于Card类型，所以就出现了TypeError异常，异常消息为：'<' not supported between\ninstances of 'Card' and 'Card'。\n\n为了解决这个问题，我们可以对Card类的代码稍作修改，使得两个Card对象可以直接用<进行大小的比较。这里用到技术叫运算符重载，Python\n中要实现对<运算符的重载，需要在类中添加一个名为__lt__的魔术方法。很显然，魔术方法__lt__中的lt是英文单词“less\nthan”的缩写，以此类推，魔术方法__gt__对应>运算符，魔术方法__le__对应<=运算符，__ge__对应>=运算符，__eq__对应==运算符，__n\ne__对应!=运算符。\n\n修改后的Card类代码如下所示。\n\n\n\n> 说明： 大家可以尝试在上面代码的基础上写一个简单的扑克游戏，如21点游戏（Black Jack），游戏的规则可以自己在网上找一找。\n\n案例2：工资结算系统。#\n\n> 要求：某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算员工的月薪。其中，部门经理的月薪是固定150\n> 00元；程序员按工作时间（以小时为单位）支付月薪，每小时200元；销售员的月薪由1800元底薪加上销售额5%的提成两部分构成。\n\n通过对上述需求的分析，可以看出部门经理、程序员、销售员都是员工，有相同的属性和行为，那么我们可以先设计一个名为Employee的父类，再通过继承的方式从这个父类\n派生出部门经理、程序员和销售员三个子类。很显然，后续的代码不会创建Employee\n类的对象，因为我们需要的是具体的员工对象，所以这个类可以设计成专门用于继承的抽象类。Python\n语言中没有定义抽象类的关键字，但是可以通过abc模块中名为ABCMeta 的元类来定义抽象类。关于元类的概念此处不展开讲解，当然大家不用纠结，照做即可。\n\n\n\n在上面的员工类中，有一个名为get_salary的方法用于结算月薪，但是由于还没有确定是哪一类员工，所以结算月薪虽然是员工的公共行为但这里却没有办法实现。对于暂\n时无法实现的方法，我们可以使用abstractmethod装饰器将其声明为抽象方法，所谓抽象方法就是只有声明没有实现的方法，声明这个方法是为了让子类去重写这个方\n法。接下来的代码展示了如何从员工类派生出部门经理、程序员、销售员这三个子类以及子类如何重写父类的抽象方法。\n\n\n\n上面的Manager、Programmer、Salesman三个类都继承自Employee，三个类都分别重写了get_salary方法。重写就是子类对父类已有的\n方法重新做出实现。相信大家已经注意到了，三个子类中的get_salary各不相同，所以这个方法在程序运行时会产生多态行为，多态简单的说就是调用相同的方法，不同的\n子类对象做不同的事情。\n\n我们通过下面的代码来完成这个工资结算系统，由于程序员和销售员需要分别录入本月的工作时间和销售额，所以在下面的代码中我们使用了 Python\n内置的isinstance函数来判断员工对象的类型。我们之前讲过的type函数也能识别对象的类型，但是isinstance函数更加强大，因为它可以判断出一个对象\n是不是某个继承结构下的子类型，你可以简单的理解为type函数是对对象类型的精准匹配，而isinstance函数是对对象类型的模糊匹配。\n\n\n\n\n总结#\n\n面向对象的编程思想非常的好，也符合人类的正常思维习惯，但是要想灵活运用面向对象编程中的抽象、封装、继承、多态需要长时间的积累和沉淀，这件事情无法一蹴而就，因为知\n识的积累本就是涓滴成河的过程。",
    "routePath": "/tutorial/python/第20课：面向对象编程应用",
    "lang": "",
    "toc": [
      {
        "text": "第20课：面向对象编程应用",
        "id": "第20课面向对象编程应用",
        "depth": 2,
        "charIndex": -1
      },
      {
        "text": "经典案例",
        "id": "经典案例",
        "depth": 3,
        "charIndex": 187
      },
      {
        "text": "案例1：扑克游戏。",
        "id": "案例1扑克游戏",
        "depth": 4,
        "charIndex": 194
      },
      {
        "text": "案例2：工资结算系统。",
        "id": "案例2工资结算系统",
        "depth": 4,
        "charIndex": 1669
      },
      {
        "text": "总结",
        "id": "总结",
        "depth": 3,
        "charIndex": 2700
      }
    ],
    "domain": "",
    "frontmatter": {},
    "version": ""
  }
]